From 09c9750bce0526193971a29a7811b755a966d237 Mon Sep 17 00:00:00 2001
From: Stefano Gurrieri <stefano.gurrieri@roj.com>
Date: Tue, 19 Nov 2019 09:16:12 +0100
Subject: [PATCH] smarc-som-support


diff --git a/arch/arm/cpu/armv7/mx6/Kconfig b/arch/arm/cpu/armv7/mx6/Kconfig
index be9f2b9..d64b0af 100644
--- a/arch/arm/cpu/armv7/mx6/Kconfig
+++ b/arch/arm/cpu/armv7/mx6/Kconfig
@@ -203,6 +203,13 @@ config TARGET_MX6QSABREAUTO
 	select DM_THERMAL
 	select BOARD_EARLY_INIT_F
 
+config TARGET_MX6QSMARC
+	bool "mx6qsmarc"
+	select BOARD_LATE_INIT
+	select DM
+	select DM_THERMAL
+	select BOARD_EARLY_INIT_F
+
 config TARGET_MX6SABRESD
 	bool "mx6sabresd"
 	select BOARD_LATE_INIT
@@ -492,6 +499,7 @@ source "board/engicam/icorem6/Kconfig"
 source "board/engicam/icorem6_rqs/Kconfig"
 source "board/freescale/mx6qarm2/Kconfig"
 source "board/freescale/mx6qsabreauto/Kconfig"
+source "board/freescale/mx6qsmarc/Kconfig"
 source "board/freescale/mx6sabresd/Kconfig"
 source "board/freescale/mx6slevk/Kconfig"
 source "board/freescale/mx6sll_arm2/Kconfig"
diff --git a/arch/arm/dts/imx6dl-smarc.dtsi b/arch/arm/dts/imx6dl-smarc.dtsi
new file mode 100644
index 0000000..f1fd136
--- /dev/null
+++ b/arch/arm/dts/imx6dl-smarc.dtsi
@@ -0,0 +1,42 @@
+/*
+ * Copyright (C) 2013 Freescale Semiconductor, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include "imx6dl.dtsi"
+#include "imx6qdl-smarc.dtsi"
+
+/ {
+};
+
+&iomuxc {
+	ipu1 {
+		pinctrl_ipu1_3: ipu1grp-3 {
+			fsl,pins = <
+				MX6QDL_PAD_EIM_DA5__IPU1_CSI1_DATA04   		 0x10
+				MX6QDL_PAD_EIM_DA4__IPU1_CSI1_DATA05   		 0x10
+				MX6QDL_PAD_EIM_DA3__IPU1_CSI1_DATA06   		 0x10
+				MX6QDL_PAD_EIM_DA2__IPU1_CSI1_DATA07   		 0x10
+				MX6QDL_PAD_EIM_DA1__IPU1_CSI1_DATA08   		 0x10
+				MX6QDL_PAD_EIM_DA0__IPU1_CSI1_DATA09   		 0x10
+				MX6QDL_PAD_EIM_EB1__IPU1_CSI1_DATA10   		 0x10
+				MX6QDL_PAD_EIM_EB0__IPU1_CSI1_DATA11   		 0x10
+				MX6QDL_PAD_EIM_A17__IPU1_CSI1_DATA12   		 0x10
+				MX6QDL_PAD_EIM_A18__IPU1_CSI1_DATA13   		 0x10
+				MX6QDL_PAD_EIM_A19__IPU1_CSI1_DATA14   		 0x10
+				MX6QDL_PAD_EIM_A20__IPU1_CSI1_DATA15   		 0x10
+				MX6QDL_PAD_EIM_A21__IPU1_CSI1_DATA16   		 0x10
+				MX6QDL_PAD_EIM_A22__IPU1_CSI1_DATA17   		 0x10
+				MX6QDL_PAD_EIM_A23__IPU1_CSI1_DATA18   		 0x10
+				MX6QDL_PAD_EIM_A24__IPU1_CSI1_DATA19   		 0x10
+				MX6QDL_PAD_EIM_DA10__IPU1_CSI1_DATA_EN 		 0x10
+				MX6QDL_PAD_EIM_D17__IPU1_CSI1_PIXCLK   		 0x10
+				MX6QDL_PAD_EIM_DA11__IPU1_CSI1_HSYNC   		 0x10
+				MX6QDL_PAD_EIM_DA12__IPU1_CSI1_VSYNC   		 0x10
+			>;
+		};
+	};
+};
diff --git a/arch/arm/dts/imx6q-smarc.dtsi b/arch/arm/dts/imx6q-smarc.dtsi
new file mode 100644
index 0000000..d246ff9
--- /dev/null
+++ b/arch/arm/dts/imx6q-smarc.dtsi
@@ -0,0 +1,56 @@
+/*
+ * Copyright 2012-2015 Freescale Semiconductor, Inc.
+ * Copyright 2011 Linaro Ltd.
+ *
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#include "imx6q.dtsi"
+#include "imx6qdl-smarc.dtsi"
+
+/ {
+};
+
+&mxcfb3 {
+	status = "okay";
+};
+&mxcfb4 {
+	status = "okay";
+};
+&sata {
+	status = "okay";
+};
+
+&iomuxc {
+	ipu2 {
+		pinctrl_ipu2_1: ipu2grp-1 {
+						fsl,pins = <
+							MX6QDL_PAD_EIM_DA5__IPU2_CSI1_DATA04   		 0x10
+							MX6QDL_PAD_EIM_DA4__IPU2_CSI1_DATA05   		 0x10
+							MX6QDL_PAD_EIM_DA3__IPU2_CSI1_DATA06   		 0x10
+							MX6QDL_PAD_EIM_DA2__IPU2_CSI1_DATA07   		 0x10
+							MX6QDL_PAD_EIM_DA1__IPU2_CSI1_DATA08   		 0x10
+							MX6QDL_PAD_EIM_DA0__IPU2_CSI1_DATA09   		 0x10
+							MX6QDL_PAD_EIM_EB1__IPU2_CSI1_DATA10   		 0x10
+							MX6QDL_PAD_EIM_EB0__IPU2_CSI1_DATA11   		 0x10
+							MX6QDL_PAD_EIM_A17__IPU2_CSI1_DATA12   		 0x10
+							MX6QDL_PAD_EIM_A18__IPU2_CSI1_DATA13   		 0x10
+							MX6QDL_PAD_EIM_A19__IPU2_CSI1_DATA14   		 0x10
+							MX6QDL_PAD_EIM_A20__IPU2_CSI1_DATA15   		 0x10
+							MX6QDL_PAD_EIM_A21__IPU2_CSI1_DATA16   		 0x10
+							MX6QDL_PAD_EIM_A22__IPU2_CSI1_DATA17   		 0x10
+							MX6QDL_PAD_EIM_A23__IPU2_CSI1_DATA18   		 0x10
+							MX6QDL_PAD_EIM_A24__IPU2_CSI1_DATA19   		 0x10
+							MX6QDL_PAD_EIM_DA10__IPU2_CSI1_DATA_EN 		 0x10
+							MX6QDL_PAD_EIM_D17__IPU2_CSI1_PIXCLK   		 0x10
+							MX6QDL_PAD_EIM_DA11__IPU2_CSI1_HSYNC   		 0x10
+							MX6QDL_PAD_EIM_DA12__IPU2_CSI1_VSYNC   		 0x10
+						>;
+						};
+	};
+};
diff --git a/arch/arm/dts/imx6qdl-smarc.dtsi b/arch/arm/dts/imx6qdl-smarc.dtsi
new file mode 100644
index 0000000..7e37f6f
--- /dev/null
+++ b/arch/arm/dts/imx6qdl-smarc.dtsi
@@ -0,0 +1,986 @@
+/*
+ * Copyright 2012-2015 Freescale Semiconductor, Inc.
+ * Copyright 2011 Linaro Ltd.
+ *
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#include <dt-bindings/gpio/gpio.h>
+#include <dt-bindings/input/input.h>
+
+/ {
+	aliases {
+		mxcfb0 = &mxcfb1;
+		mxcfb1 = &mxcfb2;
+		mxcfb2 = &mxcfb3;
+		mxcfb3 = &mxcfb4;
+	};
+
+	memory:	memory {
+		reg = <0x10000000 0x40000000>;
+	};
+
+	clocks {
+		codec_osc: anaclk2 {
+			compatible = "fixed-clock";
+			#clock-cells = <0>;
+			clock-frequency = <24576000>;
+		};
+	};
+
+	regulators: regulators {
+		compatible = "simple-bus";
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		reg_1p8v: 1p8v {
+			compatible = "regulator-fixed";
+			regulator-name = "1P8V";
+			regulator-min-microvolt = <1800000>;
+			regulator-max-microvolt = <1800000>;
+			regulator-always-on;
+		};
+
+		reg_3p3v: 3p3v {
+			compatible = "regulator-fixed";
+			regulator-name = "3P3V";
+			regulator-min-microvolt = <3300000>;
+			regulator-max-microvolt = <3300000>;
+			regulator-always-on;
+		};
+
+		reg_usb_otg_vbus: usb_otg_vbus {
+			compatible = "regulator-fixed";
+			regulator-name = "usb_otg_vbus";
+			regulator-min-microvolt = <5000000>;
+			regulator-max-microvolt = <5000000>;
+			gpio = <&gpio1 28 GPIO_ACTIVE_HIGH>;
+			enable-active-high;
+		};
+
+		reg_sd1_vmmc: sd1_vmmc {
+			compatible = "regulator-fixed";
+			regulator-name = "P3V3_SDIO_SWITCHED";
+			regulator-min-microvolt = <3300000>;
+			regulator-max-microvolt = <3300000>;
+			gpio = <&gpio2 2 GPIO_ACTIVE_LOW>;
+			enable-active-high;
+		};
+	};
+
+	sound-hdmi {
+		compatible = "fsl,imx6q-audio-hdmi",
+			     "fsl,imx-audio-hdmi";
+		model = "imx-audio-hdmi";
+		hdmi-controller = <&hdmi_audio>;
+	};
+
+	sound-spdif {
+		compatible = "fsl,imx-audio-spdif",
+			   "fsl,imx-sabreauto-spdif";
+		model = "imx-spdif";
+		spdif-controller = <&spdif>;
+		spdif-in;
+	};
+
+	mxcfb1: fb@0 {
+		compatible = "fsl,mxc_sdc_fb";
+		disp_dev = "hdmi";
+		interface_pix_fmt = "RGB24";
+		default_bpp = <24>;
+		int_clk = <0>;
+		late_init = <0>;
+		status = "okay";
+	};
+
+	mxcfb2: fb@1 {
+		compatible = "fsl,mxc_sdc_fb";
+		disp_dev = "ldb";
+		interface_pix_fmt = "RGB24";
+		mode_str ="LDB-XGA";
+		default_bpp = <24>;
+		int_clk = <0>;
+		late_init = <0>;
+		status = "okay";
+	};
+
+	mxcfb3: fb@2 {
+		compatible = "fsl,mxc_sdc_fb";
+		disp_dev = "lcd";
+		interface_pix_fmt = "RGB565";
+		mode_str ="CLAA-WVGA";
+		default_bpp = <16>;
+		int_clk = <0>;
+		late_init = <0>;
+		status = "disabled";
+	};
+
+	mxcfb4: fb@3 {
+		compatible = "fsl,mxc_sdc_fb";
+		disp_dev = "ldb";
+		interface_pix_fmt = "RGB666";
+		default_bpp = <16>;
+		int_clk = <0>;
+		late_init = <0>;
+		status = "disabled";
+	};
+
+	v4l20: v4l2_cap_0 {
+		compatible = "fsl,imx6q-v4l2-capture";
+		ipu_id = <0>;
+		csi_id = <0>;
+		mclk_source = <0>;
+		status = "okay";
+	};
+
+	v4l21: v4l2_cap_1 {
+		compatible = "fsl,imx6q-v4l2-capture";
+		ipu_id = <0>;
+		csi_id = <1>;
+		mclk_source = <0>;
+		status = "okay";
+	};
+
+	v4l2_out {
+		compatible = "fsl,mxc_v4l2_output";
+		status = "okay";
+	};
+
+	lcd: lcd@0 {
+		compatible = "fsl,lcd";
+		ipu_id = <0>;
+		disp_id = <0>;
+		default_ifmt = "RGB565";
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_ipu1_1>;
+		status = "okay";
+	};
+
+	i2c@0 {
+		compatible = "i2c-gpio";
+		gpios = <&gpio7  13  0 /* sda */
+				 &gpio7 12 0 /* scl */
+				>;
+		i2c-gpio,sda-open-drain;
+		i2c-gpio,scl-open-drain;
+		i2c-gpio,delay-us = <5>;        /* ~100 kHz */
+		i2c-gpio,timeout-ms = <100>;
+		#address-cells = <1>;
+		#size-cells  = <0>;
+	};
+
+	pu_dummy: pudummy_reg {
+		compatible = "fsl,imx6-dummy-pureg"; /* only used in ldo-bypass */
+	};
+
+};
+
+&audmux {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_audmux_2 &pinctrl_audmux_4>;
+	status = "okay";
+};
+
+/*&cpu0 {
+       arm-supply = <&sw3_reg>;
+       soc-supply = <&sw1_reg>;
+       pu-supply = <&pu_dummy>; /* use pu_dummy if VDDSOC share with VDDPU */
+//};*/
+
+/*&reg_arm {
+       vin-supply = <&sw3_reg>;
+};
+
+&reg_pu {
+       vin-supply = <&sw1_reg>;
+};
+
+&reg_soc {
+       vin-supply = <&sw1_reg>;
+};*/
+
+&ecspi2 {
+	fsl,spi-num-chipselects = <2>;
+	cs-gpios = <&gpio2 26 0 &gpio2 27 0>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_ecspi2_1 &pinctrl_ecspi2_cs_1>;
+};
+
+&ecspi4 {
+	fsl,spi-num-chipselects = <2>;
+	cs-gpios = <&gpio3 29 0 &gpio5 2 0>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_ecspi4_1 &pinctrl_ecspi4_cs_1>;
+};
+
+&esai {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_esai_1>;
+	status = "okay";
+};
+
+&fec {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_enet_1>;
+	phy-mode = "rgmii";
+	status = "okay";
+};
+
+&gpc {
+	/*fsl,cpu_pupscr_sw2iso = <0xf>;
+	fsl,cpu_pupscr_sw = <0xf>;
+	fsl,cpu_pdnscr_iso2sw = <0x1>;
+	fsl,cpu_pdnscr_iso = <0x1>;*/
+	fsl,ldo-bypass = <0>;
+};
+
+&can1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_can1_1>;
+	status = "okay"; /* pin conflict with fec */
+};
+
+&can2 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_can2_1>;
+	status = "okay";
+};
+
+&hdmi_audio {
+	status = "okay";
+};
+
+&hdmi_cec {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_hdmi_cec_1>;
+	status = "okay";
+};
+
+&hdmi_core {
+	ipu_id = <0>;
+	disp_id = <1>;
+	status = "okay";
+};
+
+&hdmi_video {
+	fsl,phy_reg_vlev = <0x0294>;
+	fsl,phy_reg_cksymtx = <0x800d>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_hdmi_hdcp_1>;
+	fsl,hdcp;
+	status = "okay";
+};
+
+&i2c1 {
+	clock-frequency = <100000>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_i2c1_1>;
+	status = "okay";
+};
+
+&i2c2 {
+	clock-frequency = <100000>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_i2c2_1>;
+	status = "okay";
+};
+
+&i2c3 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_i2c3_1>;
+	status = "okay";
+
+	eeprom@50 {
+		compatible = "st,24c64";
+		reg = <0x50>;
+		pagesize = <32>;
+	};
+
+	pcf8563: rtc@51 {
+		compatible = "nxp,pcf8563";
+		reg = <0x51>;
+	};
+
+	ltc3676: pmic@3c {
+		compatible = "lltc,ltc3676";
+		reg = <0x3c>;
+
+		regulators {
+			sw1_reg: sw1 {
+				regulator-min-microvolt = <779625>;
+				regulator-max-microvolt = <1512000>;
+				lltc,fb-voltage-divider = <178000 200000>;
+				regulator-ramp-delay = <7000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			sw2_reg: sw2 {
+				regulator-min-microvolt = <1031250>;
+				regulator-max-microvolt = <2000000>;
+				lltc,fb-voltage-divider = <270000 180000>;
+				regulator-ramp-delay = <7000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			sw3_reg: sw3 {
+				regulator-min-microvolt = <779625>;
+				regulator-max-microvolt = <1512000>;
+				lltc,fb-voltage-divider = <178000 200000>;
+				regulator-ramp-delay = <7000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			sw4_reg: sw4 {
+				regulator-min-microvolt = <855937>;
+				regulator-max-microvolt = <1660000>;
+				lltc,fb-voltage-divider = <215000 200000>;
+				regulator-ramp-delay = <7000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			ldo1_reg: ldo1 {
+				regulator-min-microvolt = <1200000>;
+				regulator-max-microvolt = <1210000>;
+				lltc,fb-voltage-divider = <133000 200000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			ldo2_reg: ldo2 {
+				regulator-min-microvolt = <2972500>;
+				regulator-max-microvolt = <2972500>;
+				lltc,fb-voltage-divider = <620000 200000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			ldo3_reg: ldo3 {
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <1800000>;
+				lltc,fb-voltage-divider = <0 0>;
+				regulator-boot-on;
+			};
+
+			ldo4_reg: ldo4 {
+				regulator-min-microvolt = <1207125>;
+				regulator-max-microvolt = <1207125>;
+				lltc,fb-voltage-divider = <133000 200000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+		};
+	};
+};
+
+&iomuxc {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_hog>;
+
+	hog {
+		pinctrl_hog: hoggrp {
+			fsl,pins = <
+				MX6QDL_PAD_GPIO_0__GPIO1_IO00        0x80000000
+				MX6QDL_PAD_GPIO_2__GPIO1_IO02        0x80000000
+				MX6QDL_PAD_GPIO_6__GPIO1_IO06        0x80000000
+				MX6QDL_PAD_GPIO_17__GPIO7_IO12       0x80000000
+				MX6QDL_PAD_GPIO_18__GPIO7_IO13       0x80000000
+				MX6QDL_PAD_NANDF_D0__GPIO2_IO00      0x80000000
+				MX6QDL_PAD_NANDF_D1__GPIO2_IO01      0x80000000
+				MX6QDL_PAD_NANDF_D2__GPIO2_IO02      0x80000000
+				MX6QDL_PAD_NANDF_D3__GPIO2_IO03      0x80000000
+				MX6QDL_PAD_NANDF_D4__GPIO2_IO04      0x80000000
+				MX6QDL_PAD_NANDF_D5__GPIO2_IO05      0x80000000
+				MX6QDL_PAD_NANDF_D6__GPIO2_IO06      0x80000000
+				MX6QDL_PAD_NANDF_D7__GPIO2_IO07      0x80000000
+				MX6QDL_PAD_EIM_A16__GPIO2_IO22       0x80000000
+				MX6QDL_PAD_EIM_DA6__GPIO3_IO06       0x80000000
+				MX6QDL_PAD_EIM_DA7__GPIO3_IO07       0x80000000
+				MX6QDL_PAD_EIM_DA8__GPIO3_IO08       0x80000000
+				MX6QDL_PAD_EIM_DA9__GPIO3_IO09       0x80000000
+				MX6QDL_PAD_EIM_DA13__GPIO3_IO13      0x80000000
+				MX6QDL_PAD_EIM_DA14__GPIO3_IO14      0x80000000
+				MX6QDL_PAD_EIM_DA15__GPIO3_IO15      0x80000000
+				MX6QDL_PAD_EIM_D18__GPIO3_IO18       0x80000000
+				MX6QDL_PAD_EIM_D30__GPIO3_IO30       0x80000000
+				MX6QDL_PAD_EIM_D31__GPIO3_IO31       0x80000000
+				MX6QDL_PAD_GPIO_19__GPIO4_IO05       0x80000000
+				MX6QDL_PAD_KEY_COL1__GPIO4_IO08      0x80000000
+				MX6QDL_PAD_KEY_ROW1__GPIO4_IO09      0x80000000
+				MX6QDL_PAD_KEY_COL2__GPIO4_IO10      0x80000000
+				MX6QDL_PAD_EIM_WAIT__GPIO5_IO00      0x80000000
+				MX6QDL_PAD_CSI0_DATA_EN__GPIO5_IO20  0x80000000
+				MX6QDL_PAD_CSI0_VSYNC__GPIO5_IO21    0x80000000
+				MX6QDL_PAD_NANDF_CLE__GPIO6_IO07     0x80000000
+				MX6QDL_PAD_NANDF_WP_B__GPIO6_IO09    0x80000000
+				MX6QDL_PAD_NANDF_RB0__GPIO6_IO10     0x80000000
+				MX6QDL_PAD_NANDF_CS0__GPIO6_IO11     0x80000000
+				MX6QDL_PAD_NANDF_CS1__GPIO6_IO14     0x80000000
+				MX6QDL_PAD_NANDF_CS2__GPIO6_IO15     0x80000000
+				MX6QDL_PAD_NANDF_CS3__GPIO6_IO16     0x80000000
+				MX6QDL_PAD_EIM_BCLK__GPIO6_IO31      0x80000000
+				MX6QDL_PAD_SD3_RST__GPIO7_IO08       0x80000000
+				MX6QDL_PAD_GPIO_3__CCM_CLKO2		 0x130b0
+			>;
+		};
+	};
+
+	/*SPI0*/
+	ecspi4 {
+		pinctrl_ecspi4_cs_1: ecspi4_cs_grp-1 {
+			fsl,pins = <
+				MX6QDL_PAD_EIM_D29__ECSPI4_SS0 0x100b1
+				MX6QDL_PAD_EIM_A25__ECSPI4_SS1 0x100b1
+			>;
+		};
+
+		pinctrl_ecspi4_1: ecspi4grp-1 {
+			fsl,pins = <
+				MX6QDL_PAD_EIM_D22__ECSPI4_MISO 0x100b1
+				MX6QDL_PAD_EIM_D28__ECSPI4_MOSI 0x100b1
+				MX6QDL_PAD_EIM_D21__ECSPI4_SCLK 0x100b1
+			>;
+		};
+	};
+
+	/*SPI1*/
+	ecspi2 {
+		pinctrl_ecspi2_cs_1: ecspi2_cs_grp-1 {
+			fsl,pins = <
+				MX6QDL_PAD_EIM_RW__ECSPI2_SS0 0x100b1
+				MX6QDL_PAD_EIM_LBA__ECSPI2_SS1 0x100b1
+			>;
+		};
+
+		pinctrl_ecspi2_1: ecspi2grp-1 {
+			fsl,pins = <
+				MX6QDL_PAD_EIM_OE__ECSPI2_MISO 0x100b1
+				MX6QDL_PAD_EIM_CS1__ECSPI2_MOSI 0x100b1
+				MX6QDL_PAD_EIM_CS0__ECSPI2_SCLK 0x100b1
+			>;
+		};
+	};
+
+	audmux {
+		/* I2S0 */
+		pinctrl_audmux_2: audmux-2 {
+			fsl,pins = <
+				MX6QDL_PAD_CSI0_DAT7__AUD3_RXD  0x130b0
+				MX6QDL_PAD_CSI0_DAT4__AUD3_TXC  0x130b0
+				MX6QDL_PAD_CSI0_DAT5__AUD3_TXD  0x110b0
+				MX6QDL_PAD_CSI0_DAT6__AUD3_TXFS 0x130b0
+			>;
+		};
+		/* I2S1 */
+		pinctrl_audmux_4: audmux-4 {
+			fsl,pins = <
+				MX6QDL_PAD_SD2_DAT2__AUD4_TXD  0x130b0
+				MX6QDL_PAD_SD2_DAT3__AUD4_TXC  0x130b0
+				MX6QDL_PAD_SD2_DAT1__AUD4_TXFS 0x130b0
+				MX6QDL_PAD_SD2_DAT0__AUD4_RXD  0x130b0
+			>;
+		};
+		pinctrl_audmux_4_2: audmux-4-2 {
+			fsl,pins = <
+				MX6QDL_PAD_SD2_DAT2__AUD4_TXD  0x130b0
+				MX6QDL_PAD_SD2_CMD__AUD4_RXC   0x130b0
+				MX6QDL_PAD_SD2_CLK__AUD4_RXFS  0x130b0
+				MX6QDL_PAD_SD2_DAT0__AUD4_RXD  0x130b0
+			>;
+		};
+	};
+
+	enet {
+		pinctrl_enet_1: enetgrp-1 {
+			fsl,pins = <
+				MX6QDL_PAD_ENET_MDIO__ENET_MDIO       0x1b0b0
+				MX6QDL_PAD_ENET_MDC__ENET_MDC         0x1b0b0
+				MX6QDL_PAD_RGMII_TXC__RGMII_TXC       0x1b0b0
+				MX6QDL_PAD_RGMII_TD0__RGMII_TD0       0x1b0b0
+				MX6QDL_PAD_RGMII_TD1__RGMII_TD1       0x1b0b0
+				MX6QDL_PAD_RGMII_TD2__RGMII_TD2       0x1b0b0
+				MX6QDL_PAD_RGMII_TD3__RGMII_TD3       0x1b0b0
+				MX6QDL_PAD_RGMII_TX_CTL__RGMII_TX_CTL 0x1b0b0
+				MX6QDL_PAD_RGMII_RXC__RGMII_RXC       0x1b0b0
+				MX6QDL_PAD_RGMII_RD0__RGMII_RD0       0x1b0b0
+				MX6QDL_PAD_RGMII_RD1__RGMII_RD1       0x1b0b0
+				MX6QDL_PAD_RGMII_RD2__RGMII_RD2       0x1b0b0
+				MX6QDL_PAD_RGMII_RD3__RGMII_RD3       0x1b0b0
+				MX6QDL_PAD_RGMII_RX_CTL__RGMII_RX_CTL 0x1b0b0
+				MX6QDL_PAD_ENET_REF_CLK__ENET_TX_CLK  0x4001b0a8
+			>;
+		};
+	};
+
+	esai {
+		pinctrl_esai_1: esaigrp-1 {
+			fsl,pins = <
+				MX6QDL_PAD_ENET_RXD1__ESAI_TX_FS     0x1b030
+				MX6QDL_PAD_ENET_TX_EN__ESAI_TX3_RX2  0x1b030
+				MX6QDL_PAD_ENET_CRS_DV__ESAI_TX_CLK  0x1b030
+				MX6QDL_PAD_ENET_TXD0__ESAI_TX4_RX1   0x1b030
+			>;
+		};
+	};
+
+	can1 {
+		pinctrl_can1_1: can1grp-1 {
+			fsl,pins = <
+				MX6QDL_PAD_GPIO_8__FLEXCAN1_RX 0x80000000
+				MX6QDL_PAD_GPIO_7__FLEXCAN1_TX 0x80000000
+			>;
+		};
+	};
+
+	can2 {
+		pinctrl_can2_1: can2grp-1 {
+			fsl,pins = <
+				MX6QDL_PAD_KEY_COL4__FLEXCAN2_TX 0x80000000
+				MX6QDL_PAD_KEY_ROW4__FLEXCAN2_RX 0x80000000
+			>;
+		};
+	};
+
+	hdmi_hdcp {
+		pinctrl_hdmi_hdcp_1: hdmihdcpgrp-1 {
+			fsl,pins = <
+				MX6QDL_PAD_KEY_COL3__HDMI_TX_DDC_SCL 0x4001b8b1
+				MX6QDL_PAD_EIM_D16__HDMI_TX_DDC_SDA  0x4001b8b1
+			>;
+		};
+	};
+
+	hdmi_cec {
+		pinctrl_hdmi_cec_1: hdmicecgrp-1 {
+			fsl,pins = <
+				MX6QDL_PAD_KEY_ROW2__HDMI_TX_CEC_LINE 0x1f8b0
+			>;
+		};
+	};
+
+	i2c1 {
+		pinctrl_i2c1_1: i2c1grp-1 {
+			fsl,pins = <
+				MX6QDL_PAD_CSI0_DAT8__I2C1_SDA 0x4001b8b1
+				MX6QDL_PAD_CSI0_DAT9__I2C1_SCL 0x4001b8b1
+			>;
+		};
+	};
+
+	i2c2 {
+		pinctrl_i2c2_1: i2c2grp-1 {
+			fsl,pins = <
+				MX6QDL_PAD_EIM_EB2__I2C2_SCL 0x4001b8b1
+				MX6QDL_PAD_KEY_ROW3__I2C2_SDA 0x4001b8b1
+			>;
+		};
+		pinctrl_i2c2_2: i2c2grp-2 {
+			fsl,pins = <
+				MX6QDL_PAD_KEY_COL3__I2C2_SCL 0x4001b8b1
+				MX6QDL_PAD_EIM_D16__I2C2_SDA 0x4001b8b1
+			>;
+		};
+	};
+
+	i2c3 {
+		pinctrl_i2c3_1: i2c3grp-1 {
+			fsl,pins = <
+				MX6QDL_PAD_GPIO_5__I2C3_SCL  0x4001b8b1
+				MX6QDL_PAD_GPIO_16__I2C3_SDA 0x4001b8b1
+			>;
+		};
+	};
+
+	ipu1 {
+		pinctrl_ipu1_1: ipu1grp-1 {
+			fsl,pins = <
+				MX6QDL_PAD_DI0_DISP_CLK__IPU1_DI0_DISP_CLK 0x10
+				MX6QDL_PAD_DI0_PIN15__IPU1_DI0_PIN15       0x10
+				MX6QDL_PAD_DI0_PIN2__IPU1_DI0_PIN02        0x10
+				MX6QDL_PAD_DI0_PIN3__IPU1_DI0_PIN03        0x10
+				MX6QDL_PAD_DI0_PIN4__IPU1_DI0_PIN04        0x80000000
+				MX6QDL_PAD_DISP0_DAT0__IPU1_DISP0_DATA00   0x10
+				MX6QDL_PAD_DISP0_DAT1__IPU1_DISP0_DATA01   0x10
+				MX6QDL_PAD_DISP0_DAT2__IPU1_DISP0_DATA02   0x10
+				MX6QDL_PAD_DISP0_DAT3__IPU1_DISP0_DATA03   0x10
+				MX6QDL_PAD_DISP0_DAT4__IPU1_DISP0_DATA04   0x10
+				MX6QDL_PAD_DISP0_DAT5__IPU1_DISP0_DATA05   0x10
+				MX6QDL_PAD_DISP0_DAT6__IPU1_DISP0_DATA06   0x10
+				MX6QDL_PAD_DISP0_DAT7__IPU1_DISP0_DATA07   0x10
+				MX6QDL_PAD_DISP0_DAT8__IPU1_DISP0_DATA08   0x10
+				MX6QDL_PAD_DISP0_DAT9__IPU1_DISP0_DATA09   0x10
+				MX6QDL_PAD_DISP0_DAT10__IPU1_DISP0_DATA10  0x10
+				MX6QDL_PAD_DISP0_DAT11__IPU1_DISP0_DATA11  0x10
+				MX6QDL_PAD_DISP0_DAT12__IPU1_DISP0_DATA12  0x10
+				MX6QDL_PAD_DISP0_DAT13__IPU1_DISP0_DATA13  0x10
+				MX6QDL_PAD_DISP0_DAT14__IPU1_DISP0_DATA14  0x10
+				MX6QDL_PAD_DISP0_DAT15__IPU1_DISP0_DATA15  0x10
+				MX6QDL_PAD_DISP0_DAT16__IPU1_DISP0_DATA16  0x10
+				MX6QDL_PAD_DISP0_DAT17__IPU1_DISP0_DATA17  0x10
+				MX6QDL_PAD_DISP0_DAT18__IPU1_DISP0_DATA18  0x10
+				MX6QDL_PAD_DISP0_DAT19__IPU1_DISP0_DATA19  0x10
+				MX6QDL_PAD_DISP0_DAT20__IPU1_DISP0_DATA20  0x10
+				MX6QDL_PAD_DISP0_DAT21__IPU1_DISP0_DATA21  0x10
+				MX6QDL_PAD_DISP0_DAT22__IPU1_DISP0_DATA22  0x10
+				MX6QDL_PAD_DISP0_DAT23__IPU1_DISP0_DATA23  0x10
+			>;
+		};
+
+		pinctrl_ipu1_2: ipu1grp-2 { /* parallel camera */
+			fsl,pins = <
+				MX6QDL_PAD_CSI0_DAT12__IPU1_CSI0_DATA12    0x80000000
+				MX6QDL_PAD_CSI0_DAT13__IPU1_CSI0_DATA13    0x80000000
+				MX6QDL_PAD_CSI0_DAT14__IPU1_CSI0_DATA14    0x80000000
+				MX6QDL_PAD_CSI0_DAT15__IPU1_CSI0_DATA15    0x80000000
+				MX6QDL_PAD_CSI0_DAT16__IPU1_CSI0_DATA16    0x80000000
+				MX6QDL_PAD_CSI0_DAT17__IPU1_CSI0_DATA17    0x80000000
+				MX6QDL_PAD_CSI0_DAT18__IPU1_CSI0_DATA18    0x80000000
+				MX6QDL_PAD_CSI0_DAT19__IPU1_CSI0_DATA19    0x80000000
+				MX6QDL_PAD_CSI0_PIXCLK__IPU1_CSI0_PIXCLK   0x80000000
+			>;
+		};
+	};
+
+	spdif {
+		pinctrl_spdif_1: spdifgrp-1 {
+			fsl,pins = <
+				MX6QDL_PAD_ENET_RX_ER__SPDIF_IN 0x1b0b0
+				MX6QDL_PAD_ENET_RXD0__SPDIF_OUT 0x1b0b0
+			>;
+		};
+	};
+
+	uart1 {
+		pinctrl_uart1_1: uart1grp-1 {
+			fsl,pins = <
+				MX6QDL_PAD_CSI0_DAT10__UART1_TX_DATA 0x1b0b1
+				MX6QDL_PAD_CSI0_DAT11__UART1_RX_DATA 0x1b0b1
+				MX6QDL_PAD_EIM_D20__UART1_RTS_B 0x1b0b1
+				MX6QDL_PAD_EIM_D19__UART1_CTS_B 0x1b0b1
+			>;
+		};
+	};
+
+	uart2 {
+		pinctrl_uart2_1: uart2grp-1 {
+			fsl,pins = <
+				MX6QDL_PAD_EIM_D26__UART2_TX_DATA 0x1b0b1
+				MX6QDL_PAD_EIM_D27__UART2_RX_DATA 0x1b0b1
+			>;
+		};
+	};
+
+	uart3 {
+		pinctrl_uart3_1: uart3grp-1 {
+			fsl,pins = <
+				MX6QDL_PAD_EIM_D25__UART3_RX_DATA 0x1b0b1
+				MX6QDL_PAD_EIM_D24__UART3_TX_DATA 0x1b0b1
+				MX6QDL_PAD_EIM_D23__UART3_CTS_B   0x1b0b1
+				MX6QDL_PAD_EIM_EB3__UART3_RTS_B   0x1b0b1
+			>;
+		};
+	};
+
+	uart4 {
+		pinctrl_uart4_1: uart4grp-1 {
+			fsl,pins = <
+				MX6QDL_PAD_KEY_COL0__UART4_TX_DATA 0x1b0b1
+				MX6QDL_PAD_KEY_ROW0__UART4_RX_DATA 0x1b0b1
+			>;
+		};
+	};
+
+	usbotg {
+		pinctrl_usbotg_1: usbotggrp-1 {
+			fsl,pins = <
+				MX6QDL_PAD_GPIO_1__USB_OTG_ID 0x17059
+			>;
+		};
+	};
+
+	usdhc1 {
+		pinctrl_usdhc1_1: usdhc1grp-1 {
+			fsl,pins = <
+				MX6QDL_PAD_SD1_CMD__SD1_CMD    0x17071
+				MX6QDL_PAD_SD1_CLK__SD1_CLK    0x10071
+				MX6QDL_PAD_SD1_DAT0__SD1_DATA0 0x17071
+				MX6QDL_PAD_SD1_DAT1__SD1_DATA1 0x17071
+				MX6QDL_PAD_SD1_DAT2__SD1_DATA2 0x17071
+				MX6QDL_PAD_SD1_DAT3__SD1_DATA3 0x17071
+			>;
+		};
+	};
+
+	usdhc3 {
+		pinctrl_usdhc3_1: usdhc3grp-1 {
+			fsl,pins = <
+				MX6QDL_PAD_SD3_CMD__SD3_CMD    0x17059
+				MX6QDL_PAD_SD3_CLK__SD3_CLK    0x10059
+				MX6QDL_PAD_SD3_DAT0__SD3_DATA0 0x17059
+				MX6QDL_PAD_SD3_DAT1__SD3_DATA1 0x17059
+				MX6QDL_PAD_SD3_DAT2__SD3_DATA2 0x17059
+				MX6QDL_PAD_SD3_DAT3__SD3_DATA3 0x17059
+				MX6QDL_PAD_SD3_DAT4__SD3_DATA4 0x17059
+				MX6QDL_PAD_SD3_DAT5__SD3_DATA5 0x17059
+				MX6QDL_PAD_SD3_DAT6__SD3_DATA6 0x17059
+				MX6QDL_PAD_SD3_DAT7__SD3_DATA7 0x17059
+			>;
+		};
+
+		pinctrl_usdhc3_1_100mhz: usdhc3grp-1-100mhz { /* 100Mhz */
+			fsl,pins = <
+				MX6QDL_PAD_SD3_CMD__SD3_CMD 0x170B9
+				MX6QDL_PAD_SD3_CLK__SD3_CLK 0x100B9
+				MX6QDL_PAD_SD3_DAT0__SD3_DATA0 0x170B9
+				MX6QDL_PAD_SD3_DAT1__SD3_DATA1 0x170B9
+				MX6QDL_PAD_SD3_DAT2__SD3_DATA2 0x170B9
+				MX6QDL_PAD_SD3_DAT3__SD3_DATA3 0x170B9
+				MX6QDL_PAD_SD3_DAT4__SD3_DATA4 0x170B9
+				MX6QDL_PAD_SD3_DAT5__SD3_DATA5 0x170B9
+				MX6QDL_PAD_SD3_DAT6__SD3_DATA6 0x170B9
+				MX6QDL_PAD_SD3_DAT7__SD3_DATA7 0x170B9
+			>;
+		};
+
+		pinctrl_usdhc3_1_200mhz: usdhc3grp-1-200mhz { /* 200Mhz */
+			fsl,pins = <
+				MX6QDL_PAD_SD3_CMD__SD3_CMD 0x170F9
+				MX6QDL_PAD_SD3_CLK__SD3_CLK 0x100F9
+				MX6QDL_PAD_SD3_DAT0__SD3_DATA0 0x170F9
+				MX6QDL_PAD_SD3_DAT1__SD3_DATA1 0x170F9
+				MX6QDL_PAD_SD3_DAT2__SD3_DATA2 0x170F9
+				MX6QDL_PAD_SD3_DAT3__SD3_DATA3 0x170F9
+				MX6QDL_PAD_SD3_DAT4__SD3_DATA4 0x170F9
+				MX6QDL_PAD_SD3_DAT5__SD3_DATA5 0x170F9
+				MX6QDL_PAD_SD3_DAT6__SD3_DATA6 0x170F9
+				MX6QDL_PAD_SD3_DAT7__SD3_DATA7 0x170F9
+			>;
+		};
+	};
+
+	usdhc4 {
+		pinctrl_usdhc4_1: usdhc4grp-1 {
+			fsl,pins = <
+				MX6QDL_PAD_SD4_CMD__SD4_CMD     0x17071
+				MX6QDL_PAD_SD4_CLK__SD4_CLK     0x17071
+				MX6QDL_PAD_SD4_DAT0__SD4_DATA0  0x17071
+				MX6QDL_PAD_SD4_DAT1__SD4_DATA1  0x17071
+				MX6QDL_PAD_SD4_DAT2__SD4_DATA2  0x17071
+				MX6QDL_PAD_SD4_DAT3__SD4_DATA3  0x17071
+				MX6QDL_PAD_SD4_DAT4__SD4_DATA4  0x17071
+				MX6QDL_PAD_SD4_DAT5__SD4_DATA5  0x17071
+				MX6QDL_PAD_SD4_DAT6__SD4_DATA6  0x17071
+				MX6QDL_PAD_SD4_DAT7__SD4_DATA7  0x17071
+				MX6QDL_PAD_NANDF_ALE__SD4_RESET 0x17059
+			>;
+		};
+
+		pinctrl_usdhc4_1_100mhz: usdhc4grp-1-100mhz {
+			fsl,pins = <
+				MX6QDL_PAD_SD4_CMD__SD4_CMD     0x170B9
+                MX6QDL_PAD_SD4_CLK__SD4_CLK     0x100B9
+				MX6QDL_PAD_SD4_DAT0__SD4_DATA0  0x170B9
+				MX6QDL_PAD_SD4_DAT1__SD4_DATA1  0x170B9
+				MX6QDL_PAD_SD4_DAT2__SD4_DATA2  0x170B9
+				MX6QDL_PAD_SD4_DAT3__SD4_DATA3  0x170B9
+				MX6QDL_PAD_SD4_DAT4__SD4_DATA4  0x170B9
+				MX6QDL_PAD_SD4_DAT5__SD4_DATA5  0x170B9
+				MX6QDL_PAD_SD4_DAT6__SD4_DATA6  0x170B9
+				MX6QDL_PAD_SD4_DAT7__SD4_DATA7  0x170B9
+				MX6QDL_PAD_NANDF_ALE__SD4_RESET 0x170B9
+			>;
+		};
+
+		pinctrl_usdhc4_1_200mhz: usdhc4grp-1-200mhz {
+			fsl,pins = <
+				MX6QDL_PAD_SD4_CMD__SD4_CMD     0x170F9
+				MX6QDL_PAD_SD4_CLK__SD4_CLK     0x100F9
+				MX6QDL_PAD_SD4_DAT0__SD4_DATA0  0x170F9
+				MX6QDL_PAD_SD4_DAT1__SD4_DATA1  0x170F9
+				MX6QDL_PAD_SD4_DAT2__SD4_DATA2  0x170F9
+				MX6QDL_PAD_SD4_DAT3__SD4_DATA3  0x170F9
+				MX6QDL_PAD_SD4_DAT4__SD4_DATA4  0x170F9
+				MX6QDL_PAD_SD4_DAT5__SD4_DATA5  0x170F9
+				MX6QDL_PAD_SD4_DAT6__SD4_DATA6  0x170F9
+				MX6QDL_PAD_SD4_DAT7__SD4_DATA7  0x170F9
+				MX6QDL_PAD_NANDF_ALE__SD4_RESET 0x170F9
+			>;
+		};
+	};
+
+	wdog {
+		pinctrl_wdog: wdoggrp-1 {
+			fsl,pins = <
+				MX6QDL_PAD_GPIO_9__WDOG1_B	0x1b0b1
+			>;
+		};
+	};
+};
+
+&ldb {
+	status = "okay";
+
+	lvds-channel@0 {
+		fsl,data-mapping = "spwg";
+		fsl,data-width = <24>;
+		crtc = "ipu1-di0";
+		primary;
+		status = "okay";
+
+		display-timings {
+			native-mode = <&timing0>;
+			timing0: hsd100pxn1 {
+				clock-frequency = <40000000>;
+				hactive = <800>;
+				vactive = <600>;
+				hback-porch = <127>;
+				hfront-porch = <128>;
+				vback-porch = <13>;
+				vfront-porch = <14>;
+				hsync-len = <1>;
+				vsync-len = <1>;
+				hsync-active = <0>;
+				vsync-active = <0>;
+			};
+		};
+	};
+
+	lvds-channel@1 {
+		fsl,data-mapping = "spwg";
+		fsl,data-width = <18>;
+		crtc = "ipu1-di1";
+		status = "disabled";
+
+		display-timings {
+			native-mode = <&timing1>;
+			timing1: hsd100pxn1 {
+				clock-frequency = <65000000>;
+				hactive = <1024>;
+				vactive = <768>;
+				hback-porch = <220>;
+				hfront-porch = <40>;
+				vback-porch = <21>;
+				vfront-porch = <7>;
+				hsync-len = <60>;
+				vsync-len = <10>;
+			};
+		};
+	};
+};
+
+&mipi_csi {
+	status = "okay";
+	ipu_id = <0>;
+	csi_id = <1>;
+	v_channel = <0>;
+	lanes = <2>;
+};
+
+&pcie {
+	reset-gpio = <&gpio1 6 0>;
+	wake-up-gpio = <&gpio2 5 0>;
+	status = "okay";
+};
+
+&spdif {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_spdif_1>;
+	status = "okay";
+};
+
+&ssi1 {
+        fsl,mode = "i2s-slave";
+        status = "okay";
+};
+
+&ssi2 {
+	fsl,mode = "i2s-master";
+	status = "okay";
+};
+
+&uart1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_uart1_1>;
+	fsl,uart-has-rtscts;
+	status = "okay";
+};
+
+&uart2 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_uart2_1>;
+	status = "okay";
+};
+
+&uart3 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_uart3_1>;
+	fsl,uart-has-rtscts;
+	status = "okay";
+};
+
+&uart4 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_uart4_1>;
+	status = "okay";
+};
+
+&usbh1 {
+	status = "okay";
+};
+
+&usbotg {
+	vbus-supply = <&reg_usb_otg_vbus>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_usbotg_1>;
+	imx6-usb-charger-detection;
+	status = "okay";
+};
+
+&usdhc1 {
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_usdhc1_1>;
+		cd-gpios = <&gpio2 1 GPIO_ACTIVE_LOW>;
+		wp-gpios = <&gpio2 0 GPIO_ACTIVE_HIGH>;
+		no-1-8-v;
+		keep-power-in-suspend;
+		enable-sdio-wakeup;
+		status = "okay";
+};
+
+&usdhc3 {
+		pinctrl-names = "default", "state_100mhz", "state_200mhz";
+		pinctrl-0 = <&pinctrl_usdhc3_1>;
+		pinctrl-1 = <&pinctrl_usdhc3_1_100mhz>;
+		pinctrl-2 = <&pinctrl_usdhc3_1_200mhz>;
+		non-removable;
+		bus-width = <8>;
+		no-1-8-v;
+		keep-power-in-suspend;
+		enable-sdio-wakeup;
+		status = "okay";
+};
+
+&usdhc4 {
+		pinctrl-names = "default", "state_100mhz", "state_200mhz";
+		pinctrl-0 = <&pinctrl_usdhc4_1>;
+		pinctrl-1 = <&pinctrl_usdhc4_1_100mhz>;
+		pinctrl-2 = <&pinctrl_usdhc4_1_200mhz>;
+		bus-width = <4>;
+		no-1-8-v;
+		non-removable;
+		keep-power-in-suspend;
+		enable-sdio-wakeup;
+		status = "okay";
+};
+
+&vpu {
+	status = "okay";
+};
diff --git a/board/freescale/mx6qsmarc/Kconfig b/board/freescale/mx6qsmarc/Kconfig
new file mode 100644
index 0000000..7f4716f
--- /dev/null
+++ b/board/freescale/mx6qsmarc/Kconfig
@@ -0,0 +1,17 @@
+if TARGET_MX6QSMARC
+
+config SYS_BOARD
+	default "mx6qsmarc"
+
+config SYS_VENDOR
+	default "freescale"
+
+config SYS_CONFIG_NAME
+	default "mx6qsmarc"
+
+config NOR
+	bool "Support for NOR flash"
+	help
+	  The i.MX SoC supports having a NOR flash connected to the WEIM.
+	  Need to set this for NOR_BOOT.
+endif
diff --git a/board/freescale/mx6qsmarc/MAINTAINERS b/board/freescale/mx6qsmarc/MAINTAINERS
new file mode 100644
index 0000000..55aedf5
--- /dev/null
+++ b/board/freescale/mx6qsmarc/MAINTAINERS
@@ -0,0 +1,5 @@
+MX6QSMARC BOARD
+M:	Stefano Gurrieri <stefano.gurrieri@roj.com>
+S:	Maintained
+F:	board/freescale/mx6qsmarc/
+F:	include/configs/mx6qsmarc.h
diff --git a/board/freescale/mx6qsmarc/Makefile b/board/freescale/mx6qsmarc/Makefile
new file mode 100644
index 0000000..d19a41a
--- /dev/null
+++ b/board/freescale/mx6qsmarc/Makefile
@@ -0,0 +1,9 @@
+#
+# Copyright (C) 2007, Stefano Gurrieri <stefano.gurrieri@roj.com>
+#
+# (C) Copyright 2011 Freescale Semiconductor, Inc.
+#
+# SPDX-License-Identifier:	GPL-2.0+
+#
+
+obj-y  := mx6qsmarc.o
diff --git a/board/freescale/mx6qsmarc/imximage.cfg b/board/freescale/mx6qsmarc/imximage.cfg
new file mode 100644
index 0000000..57d6765
--- /dev/null
+++ b/board/freescale/mx6qsmarc/imximage.cfg
@@ -0,0 +1,132 @@
+/*
+ * Copyright (C) 2012 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ *
+ * Refer doc/README.imximage for more details about how-to configure
+ * and create imximage boot image
+ *
+ * The syntax is taken as close as possible with the kwbimage
+ */
+/* image version */
+
+IMAGE_VERSION 2
+
+/*
+ * Boot Device : one of
+ * spi, sd (the board has no nand neither onenand)
+ */
+BOOT_FROM	sd
+
+/*
+ * Device Configuration Data (DCD)
+ *
+ * Each entry must have the format:
+ * Addr-type           Address        Value
+ *
+ * where:
+ *	Addr-type register length (1,2 or 4 bytes)
+ *	Address	  absolute address of the register
+ *	value	  value to be stored in the register
+ */
+
+DATA 4 0x020e0798 0x000C0000
+DATA 4 0x020e0758 0x00000000
+DATA 4 0x020e0588 0x00000030
+DATA 4 0x020e0594 0x00000030
+DATA 4 0x020e056c 0x00000030
+DATA 4 0x020e0578 0x00000030
+DATA 4 0x020e074c 0x00000030
+DATA 4 0x020e057c 0x00000030
+DATA 4 0x020e058c 0x00000000
+DATA 4 0x020e059c 0x00000030
+DATA 4 0x020e05a0 0x00000030
+DATA 4 0x020e078c 0x00000030
+DATA 4 0x020e0750 0x00020000
+DATA 4 0x020e05a8 0x00000030
+DATA 4 0x020e05b0 0x00000030
+DATA 4 0x020e0524 0x00000030
+DATA 4 0x020e051c 0x00000030
+DATA 4 0x020e0518 0x00000030
+DATA 4 0x020e050c 0x00000030
+DATA 4 0x020e05b8 0x00000030
+DATA 4 0x020e05c0 0x00000030
+DATA 4 0x020e0774 0x00020030
+DATA 4 0x020e0784 0x00000030
+DATA 4 0x020e0788 0x00000030
+DATA 4 0x020e0794 0x00000030
+DATA 4 0x020e079c 0x00000030
+DATA 4 0x020e07a0 0x00000030
+DATA 4 0x020e07a4 0x00000030
+DATA 4 0x020e07a8 0x00000030
+DATA 4 0x020e0748 0x00000030
+DATA 4 0x020e05ac 0x00000030
+DATA 4 0x020e05b4 0x00000030
+DATA 4 0x020e0528 0x00000030
+DATA 4 0x020e0520 0x00000030
+DATA 4 0x020e0514 0x00000030
+DATA 4 0x020e0510 0x00000030
+DATA 4 0x020e05bc 0x00000030
+DATA 4 0x020e05c4 0x00000030
+DATA 4 0x021b001c 0x00008000
+DATA 4 0x021b0800 0xA1390003
+DATA 4 0x021b080c 0x000D0016
+DATA 4 0x021b0810 0x001D0016
+DATA 4 0x021b480c 0x0008001F
+DATA 4 0x021b4810 0x00080014
+DATA 4 0x021b083c 0x03440354
+DATA 4 0x021b0840 0x033C033C
+DATA 4 0x021b483c 0x03540358
+DATA 4 0x021b4840 0x033C0318
+DATA 4 0x021b0848 0x4032363A
+DATA 4 0x021b4848 0x40423248
+DATA 4 0x021b0850 0x30383432
+DATA 4 0x021b4850 0x40304034
+DATA 4 0x021b081c 0x33333333
+DATA 4 0x021b0820 0x33333333
+DATA 4 0x021b0824 0x33333333
+DATA 4 0x021b0828 0x33333333
+DATA 4 0x021b481c 0x33333333
+DATA 4 0x021b4820 0x33333333
+DATA 4 0x021b4824 0x33333333
+DATA 4 0x021b4828 0x33333333
+DATA 4 0x021b08b8 0x00000800
+DATA 4 0x021b48b8 0x00000800
+DATA 4 0x021b0004 0x00020036
+DATA 4 0x021b0008 0x09444040
+DATA 4 0x021b000c 0x54597955
+DATA 4 0x021b0010 0xFF328F64
+DATA 4 0x021b0014 0x01FF00DB
+DATA 4 0x021b0018 0x00011740
+DATA 4 0x021b001c 0x00008000
+DATA 4 0x021b002c 0x000026D2
+DATA 4 0x021b0030 0x00591023
+DATA 4 0x021b0040 0x00000027
+DATA 4 0x021b0000 0x831A0000
+DATA 4 0x021b001c 0x02088032
+DATA 4 0x021b001c 0x00008033
+DATA 4 0x021b001c 0x00048031
+DATA 4 0x021b001c 0x19408030
+DATA 4 0x021b001c 0x04008040
+DATA 4 0x021b0020 0x00007800
+DATA 4 0x021b0818 0x00022227
+DATA 4 0x021b4818 0x00022227
+DATA 4 0x021b0004 0x00025576
+DATA 4 0x021b0404 0x00011006
+DATA 4 0x021b001c 0x00000000
+
+/* set the default clock gate to save power */
+DATA 4 0x020c4068 0x00C03F3F
+DATA 4 0x020c406c 0x0030FC03
+DATA 4 0x020c4070 0x0FFFC000
+DATA 4 0x020c4074 0x3FF00000
+DATA 4 0x020c4078 0xFFFFF300
+DATA 4 0x020c407c 0x0F0000F3
+DATA 4 0x020c4080 0x00000FFF
+
+/* enable AXI cache for VDOA/VPU/IPU */
+DATA 4 0x020e0010 0xF00000CF
+/* set IPU AXI-id0 Qos=0xf(bypass) AXI-id1 Qos=0x7 */
+DATA 4 0x020e0018 0x007F007F
+DATA 4 0x020e001c 0x007F007F
+
diff --git a/board/freescale/mx6qsmarc/imximage_2GB.cfg b/board/freescale/mx6qsmarc/imximage_2GB.cfg
new file mode 100644
index 0000000..5f2ee43
--- /dev/null
+++ b/board/freescale/mx6qsmarc/imximage_2GB.cfg
@@ -0,0 +1,132 @@
+/*
+ * Copyright (C) 2012 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ *
+ * Refer doc/README.imximage for more details about how-to configure
+ * and create imximage boot image
+ *
+ * The syntax is taken as close as possible with the kwbimage
+ */
+/* image version */
+
+IMAGE_VERSION 2
+
+/*
+ * Boot Device : one of
+ * spi, sd (the board has no nand neither onenand)
+ */
+BOOT_FROM	sd
+
+/*
+ * Device Configuration Data (DCD)
+ *
+ * Each entry must have the format:
+ * Addr-type           Address        Value
+ *
+ * where:
+ *	Addr-type register length (1,2 or 4 bytes)
+ *	Address	  absolute address of the register
+ *	value	  value to be stored in the register
+ */
+
+DATA 4 0x020e0798 0x000C0000
+DATA 4 0x020e0758 0x00000000
+DATA 4 0x020e0588 0x00000028
+DATA 4 0x020e0594 0x00000028
+DATA 4 0x020e056c 0x00000028
+DATA 4 0x020e0578 0x00000028
+DATA 4 0x020e074c 0x00000028
+DATA 4 0x020e057c 0x00000028
+DATA 4 0x020e058c 0x00000000
+DATA 4 0x020e059c 0x00000028
+DATA 4 0x020e05a0 0x00000028
+DATA 4 0x020e078c 0x00000028
+DATA 4 0x020e0750 0x00020000
+DATA 4 0x020e05a8 0x00000028
+DATA 4 0x020e05b0 0x00000028
+DATA 4 0x020e0524 0x00000028
+DATA 4 0x020e051c 0x00000028
+DATA 4 0x020e0518 0x00000028
+DATA 4 0x020e050c 0x00000028
+DATA 4 0x020e05b8 0x00000028
+DATA 4 0x020e05c0 0x00000028
+DATA 4 0x020e0774 0x00020000
+DATA 4 0x020e0784 0x00000028
+DATA 4 0x020e0788 0x00000028
+DATA 4 0x020e0794 0x00000028
+DATA 4 0x020e079c 0x00000028
+DATA 4 0x020e07a0 0x00000028
+DATA 4 0x020e07a4 0x00000028
+DATA 4 0x020e07a8 0x00000028
+DATA 4 0x020e0748 0x00000028
+DATA 4 0x020e05ac 0x00000028
+DATA 4 0x020e05b4 0x00000028
+DATA 4 0x020e0528 0x00000028
+DATA 4 0x020e0520 0x00000028
+DATA 4 0x020e0514 0x00000028
+DATA 4 0x020e0510 0x00000028
+DATA 4 0x020e05bc 0x00000028
+DATA 4 0x020e05c4 0x00000028
+DATA 4 0x021b001c 0x00008000
+DATA 4 0x021b0800 0xA1390003
+DATA 4 0x021b080c 0x00130018
+DATA 4 0x021b0810 0x002A001B
+DATA 4 0x021b480c 0x00090029
+DATA 4 0x021b4810 0x00070010
+DATA 4 0x021b083c 0x03280334
+DATA 4 0x021b0840 0x0324031C
+DATA 4 0x021b483c 0x03300338
+DATA 4 0x021b4840 0x0320026C
+DATA 4 0x021b0848 0x483A3C40
+DATA 4 0x021b4848 0x403E3A4A
+DATA 4 0x021b0850 0x363A3A3E
+DATA 4 0x021b4850 0x4230463C
+DATA 4 0x021b081c 0x33333333
+DATA 4 0x021b0820 0x33333333
+DATA 4 0x021b0824 0x33333333
+DATA 4 0x021b0828 0x33333333
+DATA 4 0x021b481c 0x33333333
+DATA 4 0x021b4820 0x33333333
+DATA 4 0x021b4824 0x33333333
+DATA 4 0x021b4828 0x33333333
+DATA 4 0x021b08b8 0x00000800
+DATA 4 0x021b48b8 0x00000800
+DATA 4 0x021b0004 0x00020036
+DATA 4 0x021b0008 0x24444040
+DATA 4 0x021b000c 0x898E7955
+DATA 4 0x021b0010 0xFF328F64
+DATA 4 0x021b0014 0x01FF00DB
+DATA 4 0x021b0018 0x00011740
+DATA 4 0x021b001c 0x00008000
+DATA 4 0x021b002c 0x000026D2
+DATA 4 0x021b0030 0x008E1023
+DATA 4 0x021b0040 0x00000047
+DATA 4 0x021b0000 0x841A0000
+DATA 4 0x021b001c 0x02088032
+DATA 4 0x021b001c 0x00008033
+DATA 4 0x021b001c 0x00408031
+DATA 4 0x021b001c 0x19408030
+DATA 4 0x021b001c 0x04008040
+DATA 4 0x021b0020 0x00005800
+DATA 4 0x021b0818 0x00011117
+DATA 4 0x021b4818 0x00011117
+DATA 4 0x021b0004 0x00025576
+DATA 4 0x021b0404 0x00011006
+DATA 4 0x021b001c 0x00000000
+
+/* set the default clock gate to save power */
+DATA 4 0x020c4068 0x00C03F3F
+DATA 4 0x020c406c 0x0030FC03
+DATA 4 0x020c4070 0x0FFFC000
+DATA 4 0x020c4074 0x3FF00000
+DATA 4 0x020c4078 0xFFFFF300
+DATA 4 0x020c407c 0x0F0000F3
+DATA 4 0x020c4080 0x00000FFF
+
+/* enable AXI cache for VDOA/VPU/IPU */
+DATA 4 0x020e0010 0xF00000CF
+/* set IPU AXI-id0 Qos=0xf(bypass) AXI-id1 Qos=0x7 */
+DATA 4 0x020e0018 0x007F007F
+DATA 4 0x020e001c 0x007F007F
+
diff --git a/board/freescale/mx6qsmarc/mx6dl.cfg b/board/freescale/mx6qsmarc/mx6dl.cfg
new file mode 100644
index 0000000..d11256d
--- /dev/null
+++ b/board/freescale/mx6qsmarc/mx6dl.cfg
@@ -0,0 +1,119 @@
+/*
+ * Copyright (C) 2013 Freescale Semiconductor, Inc.
+ * Jason Liu <r64343@freescale.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ *
+ * Refer doc/README.imximage for more details about how-to configure
+ * and create imximage boot image
+ *
+ * The syntax is taken as close as possible with the kwbimage
+ */
+/* image version */
+
+IMAGE_VERSION 2
+
+/*
+ * Boot Device : one of
+ * spi, sd (the board has no nand neither onenand)
+ */
+BOOT_FROM	sd
+
+/*
+ * Device Configuration Data (DCD)
+ *
+ * Each entry must have the format:
+ * Addr-type           Address        Value
+ *
+ * where:
+ *	Addr-type register length (1,2 or 4 bytes)
+ *	Address	  absolute address of the register
+ *	value	  value to be stored in the register
+ */
+DATA 4 0x020e0774 0x000C0000
+DATA 4 0x020e0754 0x00000000
+DATA 4 0x020e04ac 0x00000030
+DATA 4 0x020e04b0 0x00000030
+DATA 4 0x020e0464 0x00000030
+DATA 4 0x020e0490 0x00000030
+DATA 4 0x020e074c 0x00000030
+DATA 4 0x020e0494 0x00000030
+DATA 4 0x020e04a0 0x00000000
+DATA 4 0x020e04b4 0x00000030
+DATA 4 0x020e04b8 0x00000030
+DATA 4 0x020e076c 0x00000030
+DATA 4 0x020e0750 0x00020000
+DATA 4 0x020e04bc 0x00000028
+DATA 4 0x020e04c0 0x00000028
+DATA 4 0x020e04c4 0x00000028
+DATA 4 0x020e04c8 0x00000028
+DATA 4 0x020e04cc 0x00000028
+DATA 4 0x020e04d0 0x00000028
+DATA 4 0x020e04d4 0x00000028
+DATA 4 0x020e04d8 0x00000028
+DATA 4 0x020e0760 0x00020000
+DATA 4 0x020e0764 0x00000028
+DATA 4 0x020e0770 0x00000028
+DATA 4 0x020e0778 0x00000028
+DATA 4 0x020e077c 0x00000028
+DATA 4 0x020e0780 0x00000028
+DATA 4 0x020e0784 0x00000028
+DATA 4 0x020e078c 0x00000028
+DATA 4 0x020e0748 0x00000028
+DATA 4 0x020e0470 0x00000028
+DATA 4 0x020e0474 0x00000028
+DATA 4 0x020e0478 0x00000028
+DATA 4 0x020e047c 0x00000028
+DATA 4 0x020e0480 0x00000028
+DATA 4 0x020e0484 0x00000028
+DATA 4 0x020e0488 0x00000028
+DATA 4 0x020e048c 0x00000028
+DATA 4 0x021b0800 0xa1390003
+DATA 4 0x021b080c 0x0043004B
+DATA 4 0x021b0810 0x0038003A
+DATA 4 0x021b083c 0x030C0308
+DATA 4 0x021b0840 0x02600268
+DATA 4 0x021b0848 0x4C4E5450
+DATA 4 0x021b0850 0x3836322E
+DATA 4 0x021b081c 0x33333333
+DATA 4 0x021b0820 0x33333333
+DATA 4 0x021b0824 0x33333333
+DATA 4 0x021b0828 0x33333333
+DATA 4 0x021b08b8 0x00000800
+DATA 4 0x021b0004 0x0002002D
+DATA 4 0x021b0008 0x00333040
+DATA 4 0x021b000c 0x3F4352F3
+DATA 4 0x021b0010 0xB66D8B63
+DATA 4 0x021b0014 0x01FF00DB
+DATA 4 0x021b0018 0x00011740
+DATA 4 0x021b001c 0x00008000
+DATA 4 0x021b002c 0x000026d2
+DATA 4 0x021b0030 0x00431023
+DATA 4 0x021b0040 0x00000017
+DATA 4 0x021b0000 0x83190000
+DATA 4 0x021b001c 0x02008032
+DATA 4 0x021b001c 0x00008033
+DATA 4 0x021b001c 0x00048031
+DATA 4 0x021b001c 0x15208030
+DATA 4 0x021b001c 0x04008040
+DATA 4 0x021b0020 0x00007800
+DATA 4 0x021b0818 0x00022227
+/*DATA 4 0x021b4818 0x00022227*/
+DATA 4 0x021b0004 0x0002556D
+DATA 4 0x021b0404 0x00011006
+DATA 4 0x021b001c 0x00000000
+
+/* set the default clock gate to save power */
+DATA 4 0x020c4068 0x00C03F3F
+DATA 4 0x020c406c 0x0030FC03
+DATA 4 0x020c4070 0x0FFFC000
+DATA 4 0x020c4074 0x3FF00000
+DATA 4 0x020c4078 0xFFFFF300
+DATA 4 0x020c407c 0x0F0000C3
+DATA 4 0x020c4080 0x00000FFF
+
+/* enable AXI cache for VDOA/VPU/IPU */
+DATA 4 0x020e0010 0xF00000CF
+/* set IPU AXI-id0 Qos=0xf(bypass) AXI-id1 Qos=0x7 */
+DATA 4 0x020e0018 0x007F007F
+DATA 4 0x020e001c 0x007F007F
diff --git a/board/freescale/mx6qsmarc/mx6dl_1GB.cfg b/board/freescale/mx6qsmarc/mx6dl_1GB.cfg
new file mode 100644
index 0000000..36a9acc
--- /dev/null
+++ b/board/freescale/mx6qsmarc/mx6dl_1GB.cfg
@@ -0,0 +1,119 @@
+/*
+ * Copyright (C) 2013 Freescale Semiconductor, Inc.
+ * Jason Liu <r64343@freescale.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ *
+ * Refer doc/README.imximage for more details about how-to configure
+ * and create imximage boot image
+ *
+ * The syntax is taken as close as possible with the kwbimage
+ */
+/* image version */
+
+IMAGE_VERSION 2
+
+/*
+ * Boot Device : one of
+ * spi, sd (the board has no nand neither onenand)
+ */
+BOOT_FROM	sd
+
+/*
+ * Device Configuration Data (DCD)
+ *
+ * Each entry must have the format:
+ * Addr-type           Address        Value
+ *
+ * where:
+ *	Addr-type register length (1,2 or 4 bytes)
+ *	Address	  absolute address of the register
+ *	value	  value to be stored in the register
+ */
+DATA 4 0x020e0774 0x000C0000
+DATA 4 0x020e0754 0x00000000
+DATA 4 0x020e04ac 0x00000028
+DATA 4 0x020e04b0 0x00000028
+DATA 4 0x020e0464 0x00000028
+DATA 4 0x020e0490 0x00000028
+DATA 4 0x020e074c 0x00000028
+DATA 4 0x020e0494 0x00000028
+DATA 4 0x020e04a0 0x00000000
+DATA 4 0x020e04b4 0x00000028
+DATA 4 0x020e04b8 0x00000028
+DATA 4 0x020e076c 0x00000028
+DATA 4 0x020e0750 0x00020000
+DATA 4 0x020e04bc 0x00000028
+DATA 4 0x020e04c0 0x00000028
+DATA 4 0x020e04c4 0x00000028
+DATA 4 0x020e04c8 0x00000028
+//DATA 4 0x020e04cc 0x00000028
+//DATA 4 0x020e04d0 0x00000028
+//DATA 4 0x020e04d4 0x00000028
+//DATA 4 0x020e04d8 0x00000028
+DATA 4 0x020e0760 0x00020000
+DATA 4 0x020e0764 0x00000028
+DATA 4 0x020e0770 0x00000028
+DATA 4 0x020e0778 0x00000028
+DATA 4 0x020e077c 0x00000028
+//DATA 4 0x020e0780 0x00000028
+//DATA 4 0x020e0784 0x00000028
+//DATA 4 0x020e078c 0x00000028
+//DATA 4 0x020e0748 0x00000028
+DATA 4 0x020e0470 0x00000028
+DATA 4 0x020e0474 0x00000028
+DATA 4 0x020e0478 0x00000028
+DATA 4 0x020e047c 0x00000028
+//DATA 4 0x020e0480 0x00000028
+//DATA 4 0x020e0484 0x00000028
+//DATA 4 0x020e0488 0x00000028
+//DATA 4 0x020e048c 0x00000028
+DATA 4 0x021b0800 0xA1390003
+DATA 4 0x021b080c 0x004C0053
+DATA 4 0x021b0810 0x003E0043
+DATA 4 0x021b083c 0x02440244
+DATA 4 0x021b0840 0x02280228
+DATA 4 0x021b0848 0x4A484E4C
+DATA 4 0x021b0850 0x36382E2E
+DATA 4 0x021b081c 0x33333333
+DATA 4 0x021b0820 0x33333333
+DATA 4 0x021b0824 0x33333333
+DATA 4 0x021b0828 0x33333333
+DATA 4 0x021b08b8 0x00000800
+DATA 4 0x021b0004 0x0002002D
+DATA 4 0x021b0008 0x00333040
+DATA 4 0x021b000c 0x676B52F3
+DATA 4 0x021b0010 0xB66D8B63
+DATA 4 0x021b0014 0x01FF00DB
+DATA 4 0x021b0018 0x00011740
+DATA 4 0x021b001c 0x00008000
+DATA 4 0x021b002c 0x000026D2
+DATA 4 0x021b0030 0x006B1023
+DATA 4 0x021b0040 0x00000027
+DATA 4 0x021b0000 0x84190000
+DATA 4 0x021b001c 0x02008032
+DATA 4 0x021b001c 0x00008033
+DATA 4 0x021b001c 0x00408031
+DATA 4 0x021b001c 0x15208030
+DATA 4 0x021b001c 0x04008040
+DATA 4 0x021b0020 0x00005800
+DATA 4 0x021b0818 0x00011117
+/*DATA 4 0x021b4818 0x00022227*/
+DATA 4 0x021b0004 0x0002556D
+DATA 4 0x021b0404 0x00011006
+DATA 4 0x021b001c 0x00000000
+
+/* set the default clock gate to save power */
+DATA 4 0x020c4068 0x00C03F3F
+DATA 4 0x020c406c 0x0030FC03
+DATA 4 0x020c4070 0x0FFFC000
+DATA 4 0x020c4074 0x3FF00000
+DATA 4 0x020c4078 0xFFFFF300
+DATA 4 0x020c407c 0x0F0000C3
+DATA 4 0x020c4080 0x00000FFF
+
+/* enable AXI cache for VDOA/VPU/IPU */
+DATA 4 0x020e0010 0xF00000CF
+/* set IPU AXI-id0 Qos=0xf(bypass) AXI-id1 Qos=0x7 */
+DATA 4 0x020e0018 0x007F007F
+DATA 4 0x020e001c 0x007F007F
diff --git a/board/freescale/mx6qsmarc/mx6qsmarc.c b/board/freescale/mx6qsmarc/mx6qsmarc.c
new file mode 100644
index 0000000..49a2e6f
--- /dev/null
+++ b/board/freescale/mx6qsmarc/mx6qsmarc.c
@@ -0,0 +1,1356 @@
+/*
+ * Copyright (C) 2012-2016 Freescale Semiconductor, Inc.
+ * Copyright 2017 NXP
+ *
+ * Author: Fabio Estevam <fabio.estevam@freescale.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <asm/io.h>
+#include <asm/arch/clock.h>
+#include <asm/arch/imx-regs.h>
+#include <asm/arch/iomux.h>
+#include <asm/arch/mx6-pins.h>
+#include <linux/errno.h>
+#include <asm/gpio.h>
+#include <asm/imx-common/iomux-v3.h>
+#include <asm/imx-common/mxc_i2c.h>
+#include <asm/imx-common/boot_mode.h>
+#include <asm/imx-common/spi.h>
+#include <mmc.h>
+#include <fsl_esdhc.h>
+#include <miiphy.h>
+#include <netdev.h>
+#include <asm/arch/sys_proto.h>
+#include <i2c.h>
+#include <asm/arch/mxc_hdmi.h>
+#include <asm/imx-common/video.h>
+#include <asm/arch/crm_regs.h>
+#include <pca953x.h>
+#include <power/pmic.h>
+#include <power/pfuze100_pmic.h>
+#include <power/ltc3676_pmic.h>
+#include "../common/pfuze.h"
+
+#ifdef CONFIG_CMD_SATA
+#include <asm/imx-common/sata.h>
+#endif
+#ifdef CONFIG_FSL_FASTBOOT
+#include <fsl_fastboot.h>
+#ifdef CONFIG_ANDROID_RECOVERY
+#include <recovery.h>
+#endif
+#endif /*CONFIG_FSL_FASTBOOT*/
+
+DECLARE_GLOBAL_DATA_PTR;
+
+#define UART_PAD_CTRL  (PAD_CTL_PUS_100K_UP |			\
+	PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm |			\
+	PAD_CTL_SRE_FAST  | PAD_CTL_HYS)
+
+#define USDHC_PAD_CTRL (PAD_CTL_PUS_47K_UP |			\
+	PAD_CTL_SPEED_LOW | PAD_CTL_DSE_40ohm |			\
+	PAD_CTL_SRE_FAST  | PAD_CTL_HYS)
+
+/*Need more drive strength for SD1 slot on base board*/
+#define USDHC1_PAD_CTRL (PAD_CTL_PKE | PAD_CTL_PUE |            \
+	PAD_CTL_PUS_47K_UP  | PAD_CTL_SPEED_LOW |               \
+	PAD_CTL_DSE_40ohm   | PAD_CTL_SRE_FAST  | PAD_CTL_HYS)
+
+#define ENET_PAD_CTRL  (PAD_CTL_PUS_100K_UP |			\
+	PAD_CTL_SPEED_MED | PAD_CTL_DSE_34ohm | PAD_CTL_HYS)
+
+#define I2C_PAD_CTRL	(PAD_CTL_PUS_100K_UP |			\
+	PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm | PAD_CTL_HYS |	\
+	PAD_CTL_ODE | PAD_CTL_SRE_FAST)
+
+#define GPMI_PAD_CTRL0 (PAD_CTL_PKE | PAD_CTL_PUE | PAD_CTL_PUS_100K_UP)
+#define GPMI_PAD_CTRL1 (PAD_CTL_DSE_40ohm | PAD_CTL_SPEED_MED | \
+			PAD_CTL_SRE_FAST)
+#define GPMI_PAD_CTRL2 (GPMI_PAD_CTRL0 | GPMI_PAD_CTRL1)
+
+#define PC MUX_PAD_CTRL(I2C_PAD_CTRL)
+
+#define SPI_PAD_CTRL (PAD_CTL_HYS |				\
+	PAD_CTL_PUS_100K_DOWN | PAD_CTL_SPEED_MED |		\
+	PAD_CTL_DSE_40ohm     | PAD_CTL_SRE_FAST)
+
+#define WEIM_NOR_PAD_CTRL (PAD_CTL_PKE | PAD_CTL_PUE |          \
+	PAD_CTL_PUS_100K_UP | PAD_CTL_SPEED_MED |               \
+	PAD_CTL_DSE_40ohm   | PAD_CTL_SRE_FAST)
+
+#define OTG_ID_PAD_CTRL (PAD_CTL_PKE | PAD_CTL_PUE |		\
+	PAD_CTL_PUS_47K_UP  | PAD_CTL_SPEED_LOW |		\
+	PAD_CTL_DSE_80ohm   | PAD_CTL_SRE_FAST  | PAD_CTL_HYS)
+
+#define I2C_PMIC	1
+
+int dram_init(void)
+{
+	gd->ram_size = imx_ddr_size();
+
+	return 0;
+}
+
+static iomux_v3_cfg_t const uart1_pads[] = {
+	MX6_PAD_CSI0_DAT10__UART1_TX_DATA | MUX_PAD_CTRL(UART_PAD_CTRL),
+	MX6_PAD_CSI0_DAT11__UART1_RX_DATA | MUX_PAD_CTRL(UART_PAD_CTRL),
+	MX6_PAD_EIM_D19__UART1_RTS_B | MUX_PAD_CTRL(UART_PAD_CTRL),
+	MX6_PAD_EIM_D20__UART1_CTS_B | MUX_PAD_CTRL(UART_PAD_CTRL),
+};
+
+static iomux_v3_cfg_t const uart2_pads[] = {
+        MX6_PAD_EIM_D26__UART2_TX_DATA | MUX_PAD_CTRL(UART_PAD_CTRL),
+        MX6_PAD_EIM_D27__UART2_RX_DATA | MUX_PAD_CTRL(UART_PAD_CTRL),
+};
+
+static iomux_v3_cfg_t const uart3_pads[] = {
+        MX6_PAD_EIM_D24__UART3_TX_DATA | MUX_PAD_CTRL(UART_PAD_CTRL),
+        MX6_PAD_EIM_D25__UART3_RX_DATA | MUX_PAD_CTRL(UART_PAD_CTRL),
+        MX6_PAD_EIM_D23__UART3_RTS_B | MUX_PAD_CTRL(UART_PAD_CTRL),
+        MX6_PAD_EIM_EB3__UART3_CTS_B | MUX_PAD_CTRL(UART_PAD_CTRL),
+};
+
+static iomux_v3_cfg_t const uart4_pads[] = {
+	MX6_PAD_KEY_COL0__UART4_TX_DATA | MUX_PAD_CTRL(UART_PAD_CTRL),
+	MX6_PAD_KEY_ROW0__UART4_RX_DATA | MUX_PAD_CTRL(UART_PAD_CTRL),
+};
+
+static iomux_v3_cfg_t const enet_pads[] = {
+	MX6_PAD_ENET_MDIO__ENET_MDIO	| MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_ENET_MDC__ENET_MDC		| MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_RGMII_TXC__RGMII_TXC	| MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_RGMII_TD0__RGMII_TD0	| MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_RGMII_TD1__RGMII_TD1	| MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_RGMII_TD2__RGMII_TD2	| MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_RGMII_TD3__RGMII_TD3	| MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_RGMII_TX_CTL__RGMII_TX_CTL	| MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_ENET_REF_CLK__ENET_TX_CLK	| MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_RGMII_RXC__RGMII_RXC	| MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_RGMII_RD0__RGMII_RD0	| MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_RGMII_RD1__RGMII_RD1	| MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_RGMII_RD2__RGMII_RD2	| MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_RGMII_RD3__RGMII_RD3	| MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_RGMII_RX_CTL__RGMII_RX_CTL	| MUX_PAD_CTRL(ENET_PAD_CTRL),
+};
+
+static iomux_v3_cfg_t const gpio_pads[] = {
+	MX6_PAD_SD3_RST__GPIO7_IO08 | MUX_PAD_CTRL(NO_PAD_CTRL), //hub_reset
+	MX6_PAD_GPIO_0__GPIO1_IO00 | MUX_PAD_CTRL(NO_PAD_CTRL), //lcd_vdd_en
+	MX6_PAD_GPIO_2__GPIO1_IO02 | MUX_PAD_CTRL(NO_PAD_CTRL), //lcd_bklt_en
+	MX6_PAD_GPIO_4__GPIO1_IO04 | MUX_PAD_CTRL(NO_PAD_CTRL), //phy_reset	
+};
+
+/* I2C1 General Purpose */
+static struct i2c_pads_info i2c_pad_info1 = {
+        .scl = {
+                .i2c_mode = MX6_PAD_CSI0_DAT9__I2C1_SCL | PC,
+                .gpio_mode = MX6_PAD_CSI0_DAT9__GPIO5_IO27 | PC,
+                .gp = IMX_GPIO_NR(5, 27)
+        },
+        .sda = {
+                .i2c_mode = MX6_PAD_CSI0_DAT8__I2C1_SDA | PC,
+                .gpio_mode = MX6_PAD_CSI0_DAT8__GPIO5_IO26 | PC,
+                .gp = IMX_GPIO_NR(5, 26)
+        }
+};
+
+/* I2C2 Camera */
+static struct i2c_pads_info i2c_pad_info2 = {
+        .scl = {
+                .i2c_mode = MX6_PAD_EIM_EB2__I2C2_SCL | PC,
+                .gpio_mode = MX6_PAD_EIM_EB2__GPIO2_IO30 | PC,
+                .gp = IMX_GPIO_NR(2, 30)
+        },
+        .sda = {
+                .i2c_mode = MX6_PAD_KEY_ROW3__I2C2_SDA | PC,
+                .gpio_mode = MX6_PAD_KEY_ROW3__GPIO4_IO13 | PC,
+                .gp = IMX_GPIO_NR(4, 13)
+        }
+};
+
+/* I2C3 PMIC, iPod, Tuner, Codec, Touch, HDMI EDID, MIPI CSI2 card */
+static struct i2c_pads_info i2c_pad_info3 = {
+	.scl = {
+		.i2c_mode = MX6_PAD_GPIO_5__I2C3_SCL | PC,
+		.gpio_mode = MX6_PAD_GPIO_5__GPIO1_IO05 | PC,
+		.gp = IMX_GPIO_NR(1, 05)
+	},
+	.sda = {
+		.i2c_mode = MX6_PAD_GPIO_16__I2C3_SDA | PC,
+		.gpio_mode = MX6_PAD_GPIO_16__GPIO7_IO11 | PC,
+		.gp = IMX_GPIO_NR(7, 11)
+	}
+};
+
+#if 0
+#ifdef CONFIG_PCA953X
+
+/*Define for building port exp gpio, pin starts from 0*/
+#define PORTEXP_IO_NR(chip, pin) \
+	((chip << 5) + pin)
+
+/*Get the chip addr from a ioexp gpio*/
+#define PORTEXP_IO_TO_CHIP(gpio_nr) \
+	(gpio_nr >> 5)
+
+/*Get the pin number from a ioexp gpio*/
+#define PORTEXP_IO_TO_PIN(gpio_nr) \
+	(gpio_nr & 0x1f)
+
+static int port_exp_direction_output(unsigned gpio, int value)
+{
+	int ret;
+
+	i2c_set_bus_num(2);
+	ret = i2c_probe(PORTEXP_IO_TO_CHIP(gpio));
+	if (ret)
+		return ret;
+
+	ret = pca953x_set_dir(PORTEXP_IO_TO_CHIP(gpio),
+		(1 << PORTEXP_IO_TO_PIN(gpio)),
+		(PCA953X_DIR_OUT << PORTEXP_IO_TO_PIN(gpio)));
+
+	if (ret)
+		return ret;
+
+	ret = pca953x_set_val(PORTEXP_IO_TO_CHIP(gpio),
+		(1 << PORTEXP_IO_TO_PIN(gpio)),
+		(value << PORTEXP_IO_TO_PIN(gpio)));
+
+	if (ret)
+		return ret;
+
+	return 0;
+}
+#endif
+#endif
+
+#ifdef CONFIG_MTD_NOR_FLASH
+static iomux_v3_cfg_t const eimnor_pads[] = {
+	MX6_PAD_EIM_D16__EIM_DATA16	| MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_EIM_D17__EIM_DATA17	| MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_EIM_D18__EIM_DATA18	| MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_EIM_D19__EIM_DATA19	| MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_EIM_D20__EIM_DATA20	| MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_EIM_D21__EIM_DATA21	| MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_EIM_D22__EIM_DATA22	| MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_EIM_D23__EIM_DATA23	| MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_EIM_D24__EIM_DATA24	| MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_EIM_D25__EIM_DATA25	| MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_EIM_D26__EIM_DATA26	| MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_EIM_D27__EIM_DATA27	| MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_EIM_D28__EIM_DATA28	| MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_EIM_D29__EIM_DATA29	| MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_EIM_D30__EIM_DATA30	| MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_EIM_D31__EIM_DATA31	| MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_EIM_DA0__EIM_AD00	| MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_EIM_DA1__EIM_AD01	| MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_EIM_DA2__EIM_AD02	| MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_EIM_DA3__EIM_AD03	| MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_EIM_DA4__EIM_AD04	| MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_EIM_DA5__EIM_AD05	| MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_EIM_DA6__EIM_AD06	| MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_EIM_DA7__EIM_AD07	| MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_EIM_DA8__EIM_AD08	| MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_EIM_DA9__EIM_AD09	| MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_EIM_DA10__EIM_AD10	| MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_EIM_DA11__EIM_AD11	| MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL) ,
+	MX6_PAD_EIM_DA12__EIM_AD12	| MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_EIM_DA13__EIM_AD13	| MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_EIM_DA14__EIM_AD14	| MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_EIM_DA15__EIM_AD15	| MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_EIM_A16__EIM_ADDR16	| MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_EIM_A17__EIM_ADDR17	| MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_EIM_A18__EIM_ADDR18	| MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_EIM_A19__EIM_ADDR19	| MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_EIM_A20__EIM_ADDR20	| MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_EIM_A21__EIM_ADDR21	| MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_EIM_A22__EIM_ADDR22	| MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_EIM_A23__EIM_ADDR23	| MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_EIM_OE__EIM_OE_B	| MUX_PAD_CTRL(NO_PAD_CTRL),
+	MX6_PAD_EIM_RW__EIM_RW		| MUX_PAD_CTRL(NO_PAD_CTRL),
+	MX6_PAD_EIM_CS0__EIM_CS0_B	| MUX_PAD_CTRL(NO_PAD_CTRL),
+};
+
+static void eimnor_cs_setup(void)
+{
+	struct weim *weim_regs = (struct weim *)WEIM_BASE_ADDR;
+
+	writel(0x00020181, &weim_regs->cs0gcr1);
+	writel(0x00000001, &weim_regs->cs0gcr2);
+	writel(0x0a020000, &weim_regs->cs0rcr1);
+	writel(0x0000c000, &weim_regs->cs0rcr2);
+	writel(0x0804a240, &weim_regs->cs0wcr1);
+	writel(0x00000120, &weim_regs->wcr);
+
+	set_chipselect_size(CS0_128);
+}
+
+static void eim_clk_setup(void)
+{
+	struct mxc_ccm_reg *imx_ccm = (struct mxc_ccm_reg *)CCM_BASE_ADDR;
+	int cscmr1, ccgr6;
+
+
+	/* Turn off EIM clock */
+	ccgr6 = readl(&imx_ccm->CCGR6);
+	ccgr6 &= ~(0x3 << 10);
+	writel(ccgr6, &imx_ccm->CCGR6);
+
+	/*
+	 * Configure clk_eim_slow_sel = 00 --> derive clock from AXI clk root
+	 * and aclk_eim_slow_podf = 01 --> divide by 2
+	 * so that we can have EIM at the maximum clock of 132MHz
+	 */
+	cscmr1 = readl(&imx_ccm->cscmr1);
+	cscmr1 &= ~(MXC_CCM_CSCMR1_ACLK_EMI_SLOW_MASK |
+		    MXC_CCM_CSCMR1_ACLK_EMI_SLOW_PODF_MASK);
+	cscmr1 |= (1 << MXC_CCM_CSCMR1_ACLK_EMI_SLOW_PODF_OFFSET);
+	writel(cscmr1, &imx_ccm->cscmr1);
+
+	/* Turn on EIM clock */
+	ccgr6 |= (0x3 << 10);
+	writel(ccgr6, &imx_ccm->CCGR6);
+}
+
+static void setup_iomux_eimnor(void)
+{
+	imx_iomux_v3_setup_multiple_pads(eimnor_pads, ARRAY_SIZE(eimnor_pads));
+
+	gpio_direction_output(IMX_GPIO_NR(5, 4), 0);
+
+	eimnor_cs_setup();
+}
+#endif
+
+#define IOMUX_SW_PAD_CTRL_GRP_DDR_TYPE_RGMII       0x02e0790
+#define IOMUX_SW_PAD_CTRL_GRP_DDR_TYPE_RGMII_1P2V  0x00080000
+#define IOMUX_SW_PAD_CTRL_GRP_DDR_TYPE_RGMII_1P5V  0x000C0000
+
+static void setup_iomux_enet(void)
+{
+	imx_iomux_v3_setup_multiple_pads(enet_pads, ARRAY_SIZE(enet_pads));
+	__raw_writel(IOMUX_SW_PAD_CTRL_GRP_DDR_TYPE_RGMII_1P5V,
+							 (void *)IOMUX_SW_PAD_CTRL_GRP_DDR_TYPE_RGMII);
+}
+
+static void setup_iomux_gpio(void)
+{
+	imx_iomux_v3_setup_multiple_pads(gpio_pads, ARRAY_SIZE(gpio_pads));
+}
+
+iomux_v3_cfg_t const usdhc1_pads[] = {
+	MX6_PAD_SD1_CLK__SD1_CLK	| MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD1_CMD__SD1_CMD	| MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD1_DAT0__SD1_DATA0	| MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD1_DAT1__SD1_DATA1	| MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD1_DAT2__SD1_DATA2	| MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD1_DAT3__SD1_DATA3	| MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_NANDF_D0__GPIO2_IO00	| MUX_PAD_CTRL(NO_PAD_CTRL), /* WP */
+	MX6_PAD_NANDF_D1__GPIO2_IO01	| MUX_PAD_CTRL(NO_PAD_CTRL), /* CD */
+	MX6_PAD_NANDF_D2__GPIO2_IO02	| MUX_PAD_CTRL(NO_PAD_CTRL), /* PWR_EN */
+};
+
+iomux_v3_cfg_t const usdhc3_pads[] = {
+	MX6_PAD_SD3_CLK__SD3_CLK   | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD3_CMD__SD3_CMD   | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD3_DAT0__SD3_DATA0 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD3_DAT1__SD3_DATA1 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD3_DAT2__SD3_DATA2 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD3_DAT3__SD3_DATA3 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD3_DAT4__SD3_DATA4 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD3_DAT5__SD3_DATA5 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD3_DAT6__SD3_DATA6 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD3_DAT7__SD3_DATA7 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+};
+
+iomux_v3_cfg_t const usdhc4_pads[] = {
+	MX6_PAD_SD4_CLK__SD4_CLK   | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD4_CMD__SD4_CMD   | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD4_DAT0__SD4_DATA0 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD4_DAT1__SD4_DATA1 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD4_DAT2__SD4_DATA2 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD4_DAT3__SD4_DATA3 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD4_DAT4__SD4_DATA4 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD4_DAT5__SD4_DATA5 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD4_DAT6__SD4_DATA6 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD4_DAT7__SD4_DATA7 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_NANDF_ALE__GPIO6_IO08 | MUX_PAD_CTRL(NO_PAD_CTRL), /* reset */
+};
+
+static void setup_iomux_uart(void)
+{
+	imx_iomux_v3_setup_multiple_pads(uart1_pads, ARRAY_SIZE(uart1_pads));
+    imx_iomux_v3_setup_multiple_pads(uart2_pads, ARRAY_SIZE(uart2_pads));
+    imx_iomux_v3_setup_multiple_pads(uart3_pads, ARRAY_SIZE(uart3_pads));
+    imx_iomux_v3_setup_multiple_pads(uart4_pads, ARRAY_SIZE(uart4_pads));
+}
+
+#ifdef CONFIG_FSL_ESDHC
+
+static struct fsl_esdhc_cfg usdhc_cfg[3] = {
+	{USDHC1_BASE_ADDR},
+	{USDHC3_BASE_ADDR},
+	{USDHC4_BASE_ADDR},
+};
+
+int board_mmc_get_env_dev(int devno)
+{
+	//return CONFIG_SYS_MMC_ENV_DEV;
+	u32 soc_sbmr = readl(SRC_BASE_ADDR + 0x4);
+	u32 dev_no;
+
+	/* BOOT_CFG2[3] and BOOT_CFG2[4] */
+	dev_no = (soc_sbmr & 0x00001800) >> 11;
+
+	/* need ubstract 1 to map to the mmc device id
+	 * see the comments in board_mmc_init function
+	 */
+
+	if (dev_no>0) dev_no--;
+
+	return dev_no;
+}
+
+int mmc_map_to_kernel_blk(int devno)
+{
+	if (devno > 0)
+		devno++ ;
+
+	return devno;
+}
+
+#define USDHC1_CD_GPIO	IMX_GPIO_NR(2, 1)
+
+int board_mmc_getcd(struct mmc *mmc)
+{
+	struct fsl_esdhc_cfg *cfg = (struct fsl_esdhc_cfg *)mmc->priv;
+	int ret = 0;
+
+	switch (cfg->esdhc_base) {
+	case USDHC1_BASE_ADDR:
+		ret = !gpio_get_value(USDHC1_CD_GPIO);
+		break;
+	case USDHC3_BASE_ADDR:
+	case USDHC4_BASE_ADDR:
+	       ret = 1;
+	       break;
+	}
+
+	return ret;
+}
+
+int board_mmc_init(bd_t *bis)
+{
+	int i;
+
+	/*
+	 * According to the board_mmc_init() the following map is done:
+	 * (U-boot device node)    (Physical Port)
+	 * mmc0                    SDIO     (SD1)
+	 * mmc1                    eMMC     (SD3)
+	 * mmc2                    ext eMMC (SD4)
+	 */
+	for (i = 0; i < CONFIG_SYS_FSL_USDHC_NUM; i++) {
+		switch (i) {
+		case 0:
+			imx_iomux_v3_setup_multiple_pads(
+				usdhc1_pads, ARRAY_SIZE(usdhc1_pads));
+			gpio_direction_input(USDHC1_CD_GPIO);
+			usdhc_cfg[0].sdhc_clk = mxc_get_clock(MXC_ESDHC_CLK);
+			break;
+		case 1:
+			imx_iomux_v3_setup_multiple_pads(
+				usdhc3_pads, ARRAY_SIZE(usdhc3_pads));
+			usdhc_cfg[1].sdhc_clk = mxc_get_clock(MXC_ESDHC3_CLK);
+			break;
+		case 2:
+			imx_iomux_v3_setup_multiple_pads(
+				usdhc4_pads, ARRAY_SIZE(usdhc4_pads));
+			usdhc_cfg[2].sdhc_clk = mxc_get_clock(MXC_ESDHC4_CLK);
+			break;
+		default:
+			printf("Warning: you configured more USDHC controllers"
+				"(%d) than supported by the board\n", i + 1);
+			return 0;
+	       }
+
+	       if (fsl_esdhc_initialize(bis, &usdhc_cfg[i]))
+			printf("Warning: failed to initialize mmc dev %d\n", i);
+	}
+
+	return 0;
+}
+#endif
+
+#ifdef CONFIG_NAND_MXS
+static iomux_v3_cfg_t gpmi_pads[] = {
+	MX6_PAD_NANDF_CLE__NAND_CLE		| MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6_PAD_NANDF_ALE__NAND_ALE		| MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6_PAD_NANDF_WP_B__NAND_WP_B	| MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6_PAD_NANDF_RB0__NAND_READY_B	| MUX_PAD_CTRL(GPMI_PAD_CTRL0),
+	MX6_PAD_NANDF_CS0__NAND_CE0_B	| MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6_PAD_SD4_CMD__NAND_RE_B		| MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6_PAD_SD4_CLK__NAND_WE_B		| MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6_PAD_NANDF_D0__NAND_DATA00	| MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6_PAD_NANDF_D1__NAND_DATA01	| MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6_PAD_NANDF_D2__NAND_DATA02	| MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6_PAD_NANDF_D3__NAND_DATA03	| MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6_PAD_NANDF_D4__NAND_DATA04	| MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6_PAD_NANDF_D5__NAND_DATA05	| MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6_PAD_NANDF_D6__NAND_DATA06	| MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6_PAD_NANDF_D7__NAND_DATA07	| MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6_PAD_SD4_DAT0__NAND_DQS		| MUX_PAD_CTRL(GPMI_PAD_CTRL1),
+};
+
+static void setup_gpmi_nand(void)
+{
+	struct mxc_ccm_reg *mxc_ccm = (struct mxc_ccm_reg *)CCM_BASE_ADDR;
+
+	/* config gpmi nand iomux */
+	imx_iomux_v3_setup_multiple_pads(gpmi_pads, ARRAY_SIZE(gpmi_pads));
+
+	setup_gpmi_io_clk((MXC_CCM_CS2CDR_ENFC_CLK_PODF(0) |
+			MXC_CCM_CS2CDR_ENFC_CLK_PRED(3) |
+			MXC_CCM_CS2CDR_ENFC_CLK_SEL(3)));
+
+	/* enable apbh clock gating */
+	setbits_le32(&mxc_ccm->CCGR0, MXC_CCM_CCGR0_APBHDMA_MASK);
+}
+#endif
+
+int mx6_rgmii_rework(struct phy_device *phydev)
+{
+#if 0
+	unsigned short val;
+
+	/* To enable AR8031 ouput a 125MHz clk from CLK_25M */
+	phy_write(phydev, MDIO_DEVAD_NONE, 0xd, 0x7);
+	phy_write(phydev, MDIO_DEVAD_NONE, 0xe, 0x8016);
+	phy_write(phydev, MDIO_DEVAD_NONE, 0xd, 0x4007);
+
+	val = phy_read(phydev, MDIO_DEVAD_NONE, 0xe);
+	val &= 0xffe3;
+	val |= 0x18;
+	phy_write(phydev, MDIO_DEVAD_NONE, 0xe, val);
+
+	/* introduce tx clock delay */
+	phy_write(phydev, MDIO_DEVAD_NONE, 0x1d, 0x5);
+	val = phy_read(phydev, MDIO_DEVAD_NONE, 0x1e);
+	val |= 0x0100;
+	phy_write(phydev, MDIO_DEVAD_NONE, 0x1e, val);
+#endif
+	phydev->drv->writeext(phydev,CONFIG_FEC_MXC_PHYADDR,2,8,0x294);
+	return 0;
+}
+
+int board_phy_config(struct phy_device *phydev)
+{
+	mx6_rgmii_rework(phydev);
+
+	if (phydev->drv->config)
+		phydev->drv->config(phydev);
+
+	return 0;
+}
+
+static void setup_fec(void)
+{
+#if 0
+	int ret;
+
+	if (is_mx6dqp()) {
+		/*
+		 * select ENET MAC0 TX clock from PLL
+		 */
+		imx_iomux_set_gpr_register(5, 9, 1, 1);
+	} else {
+		imx_iomux_set_gpr_register(1, 21, 1, 1);
+	}
+
+	ret = enable_fec_anatop_clock(0, ENET_125MHZ);
+	if (ret)
+		printf("Error fec anatop clock settings!\n");
+#endif
+	// reset PHY and ensure RX_DV is pulled high to enable TX_REF_CLK
+	gpio_request(IMX_GPIO_NR(1, 4), "phy_reset");
+	gpio_direction_input(IMX_GPIO_NR(1,4));
+	udelay(50000);
+}
+
+int board_eth_init(bd_t *bis)
+{
+	// Reset PHY and ensure RX_DV is pulled high to enable REF_CLK
+	gpio_request(IMX_GPIO_NR(1, 4), "phy_reset");
+	gpio_direction_output(IMX_GPIO_NR(1,4),0);
+	imx_iomux_v3_setup_pad(NEW_PAD_CTRL(MX6_PAD_RGMII_RX_CTL__RGMII_RX_CTL,ENET_PAD_CTRL)); // CLK125_EN strap pin
+	imx_iomux_v3_setup_pad(NEW_PAD_CTRL(MX6_PAD_RGMII_RXC__RGMII_RXC,ENET_PAD_CTRL)); // PHYAD2 strap pin
+	
+	udelay(10000);
+	setup_fec();
+	setup_iomux_enet();
+
+	return cpu_eth_init(bis);
+}
+
+#define BOARD_REV_B  0x200
+#define BOARD_REV_A  0x100
+
+static int mx6smarc_rev(void)
+{
+	/*
+	 * Get Board ID information from OCOTP_GP1[15:8]
+	 * i.MX6Q ARD RevA: 0x01
+	 * i.MX6Q ARD RevB: 0x02
+	 */
+	struct ocotp_regs *ocotp = (struct ocotp_regs *)OCOTP_BASE_ADDR;
+	struct fuse_bank *bank = &ocotp->bank[4];
+	struct fuse_bank4_regs *fuse =
+			(struct fuse_bank4_regs *)bank->fuse_regs;
+	int reg = readl(&fuse->gp1);
+	int ret;
+
+	switch (reg >> 8 & 0x0F) {
+	case 0x02:
+		ret = BOARD_REV_B;
+		break;
+	case 0x01:
+	default:
+		ret = BOARD_REV_A;
+		break;
+	}
+
+	return ret;
+}
+
+u32 get_board_rev(void)
+{
+	int rev = mx6smarc_rev();
+
+	return (get_cpu_rev() & ~(0xF << 8)) | rev;
+}
+
+#if defined(CONFIG_VIDEO_IPUV3)
+#if 0
+static void disable_lvds(struct display_info_t const *dev)
+{
+	struct iomuxc *iomux = (struct iomuxc *)IOMUXC_BASE_ADDR;
+
+	clrbits_le32(&iomux->gpr[2],
+		     IOMUXC_GPR2_LVDS_CH0_MODE_MASK |
+		     IOMUXC_GPR2_LVDS_CH1_MODE_MASK);
+}
+#endif
+
+static void do_enable_hdmi(struct display_info_t const *dev)
+{
+	//disable_lvds(dev);
+	imx_enable_hdmi_phy();
+}
+
+struct display_info_t const displays[] = {
+#if 0
+{
+	.bus	= -1,
+	.addr	= 0,
+	.pixfmt	= IPU_PIX_FMT_RGB666,
+	.detect	= NULL,
+	.enable	= NULL,
+	.mode	= {
+		.name           = "Hannstar-XGA",
+		.refresh        = 60,
+		.xres           = 1024,
+		.yres           = 768,
+		.pixclock       = 15385,
+		.left_margin    = 220,
+		.right_margin   = 40,
+		.upper_margin   = 21,
+		.lower_margin   = 7,
+		.hsync_len      = 60,
+		.vsync_len      = 10,
+		.sync           = FB_SYNC_EXT,
+		.vmode          = FB_VMODE_NONINTERLACED
+} },
+#endif
+{
+	.bus	= -1,
+	.addr	= 0,
+	.pixfmt	= IPU_PIX_FMT_RGB24,
+	.detect	= NULL,
+	.enable	= do_enable_hdmi,
+	.mode	= {
+		.name           = "HDMI",
+		.refresh        = 60,
+		.xres           = 1024,
+		.yres           = 768,
+		.pixclock       = 15385,
+		.left_margin    = 220,
+		.right_margin   = 40,
+		.upper_margin   = 21,
+		.lower_margin   = 7,
+		.hsync_len      = 60,
+		.vsync_len      = 10,
+		.sync           = 0,
+		.vmode          = FB_VMODE_NONINTERLACED,
+} } };
+size_t display_count = ARRAY_SIZE(displays);
+
+#if 0
+iomux_v3_cfg_t const backlight_pads[] = {
+	MX6_PAD_SD4_DAT1__GPIO2_IO09 | MUX_PAD_CTRL(ENET_PAD_CTRL),
+};
+
+static void setup_iomux_backlight(void)
+{
+	gpio_request(IMX_GPIO_NR(2, 9), "backlight");
+	gpio_direction_output(IMX_GPIO_NR(2, 9), 1);
+	imx_iomux_v3_setup_multiple_pads(backlight_pads,
+					 ARRAY_SIZE(backlight_pads));
+}
+#endif
+
+static void setup_display(void)
+{
+	struct mxc_ccm_reg *mxc_ccm = (struct mxc_ccm_reg *)CCM_BASE_ADDR;
+	struct iomuxc *iomux = (struct iomuxc *)IOMUXC_BASE_ADDR;
+	int reg;
+
+	//setup_iomux_backlight();
+	enable_ipu_clock();
+	imx_setup_hdmi();
+
+	/* Turn on LDB_DI0 and LDB_DI1 clocks */
+	reg = readl(&mxc_ccm->CCGR3);
+	reg |= MXC_CCM_CCGR3_LDB_DI0_MASK | MXC_CCM_CCGR3_LDB_DI1_MASK;
+	writel(reg, &mxc_ccm->CCGR3);
+
+	/* Set LDB_DI0 and LDB_DI1 clk select to 3b'011 */
+	reg = readl(&mxc_ccm->cs2cdr);
+	reg &= ~(MXC_CCM_CS2CDR_LDB_DI0_CLK_SEL_MASK |
+		 MXC_CCM_CS2CDR_LDB_DI1_CLK_SEL_MASK);
+	reg |= (3 << MXC_CCM_CS2CDR_LDB_DI0_CLK_SEL_OFFSET) |
+	       (3 << MXC_CCM_CS2CDR_LDB_DI1_CLK_SEL_OFFSET);
+	writel(reg, &mxc_ccm->cs2cdr);
+
+	reg = readl(&mxc_ccm->cscmr2);
+	reg |= MXC_CCM_CSCMR2_LDB_DI0_IPU_DIV | MXC_CCM_CSCMR2_LDB_DI1_IPU_DIV;
+	writel(reg, &mxc_ccm->cscmr2);
+
+	reg = readl(&mxc_ccm->chsccdr);
+	reg |= (CHSCCDR_CLK_SEL_LDB_DI0
+		<< MXC_CCM_CHSCCDR_IPU1_DI0_CLK_SEL_OFFSET);
+	reg |= (CHSCCDR_CLK_SEL_LDB_DI0 <<
+		MXC_CCM_CHSCCDR_IPU1_DI1_CLK_SEL_OFFSET);
+	writel(reg, &mxc_ccm->chsccdr);
+
+	reg = IOMUXC_GPR2_DI1_VS_POLARITY_ACTIVE_LOW |
+	      IOMUXC_GPR2_DI0_VS_POLARITY_ACTIVE_LOW |
+	      IOMUXC_GPR2_BIT_MAPPING_CH1_SPWG |
+	      IOMUXC_GPR2_DATA_WIDTH_CH1_18BIT |
+	      IOMUXC_GPR2_BIT_MAPPING_CH0_SPWG |
+	      IOMUXC_GPR2_DATA_WIDTH_CH0_18BIT |
+	      IOMUXC_GPR2_LVDS_CH0_MODE_ENABLED_DI0 |
+	      IOMUXC_GPR2_LVDS_CH1_MODE_DISABLED;
+	writel(reg, &iomux->gpr[2]);
+
+	reg = readl(&iomux->gpr[3]);
+	reg &= ~(IOMUXC_GPR3_LVDS0_MUX_CTL_MASK |
+		 IOMUXC_GPR3_HDMI_MUX_CTL_MASK);
+	reg |= (IOMUXC_GPR3_MUX_SRC_IPU1_DI0 <<
+		IOMUXC_GPR3_LVDS0_MUX_CTL_OFFSET) |
+	       (IOMUXC_GPR3_MUX_SRC_IPU1_DI0 <<
+		IOMUXC_GPR3_HDMI_MUX_CTL_OFFSET);
+	writel(reg, &iomux->gpr[3]);
+}
+#endif /* CONFIG_VIDEO_IPUV3 */
+
+/*
+ * Do not overwrite the console
+ * Use always serial for U-Boot console
+ */
+int overwrite_console(void)
+{
+	return 1;
+}
+
+#ifdef CONFIG_MXC_SPI
+iomux_v3_cfg_t const ecspi1_pads[] = {
+	MX6_PAD_EIM_D16__ECSPI1_SCLK | MUX_PAD_CTRL(SPI_PAD_CTRL),
+	MX6_PAD_EIM_D17__ECSPI1_MISO | MUX_PAD_CTRL(SPI_PAD_CTRL),
+	MX6_PAD_EIM_D18__ECSPI1_MOSI | MUX_PAD_CTRL(SPI_PAD_CTRL),
+	MX6_PAD_EIM_D19__GPIO3_IO19  | MUX_PAD_CTRL(NO_PAD_CTRL),
+	/* Steer logic */
+	MX6_PAD_EIM_A24__GPIO5_IO04  | MUX_PAD_CTRL(NO_PAD_CTRL),
+};
+
+void setup_spinor(void)
+{
+	imx_iomux_v3_setup_multiple_pads(ecspi1_pads,
+					 ARRAY_SIZE(ecspi1_pads));
+
+	gpio_request(IMX_GPIO_NR(3, 19), "escpi cs");
+	gpio_direction_output(IMX_GPIO_NR(5, 4), 0);
+	gpio_direction_output(IMX_GPIO_NR(3, 19), 0);
+}
+
+int board_spi_cs_gpio(unsigned bus, unsigned cs)
+{
+	return (bus == 0 && cs == 1) ? (IMX_GPIO_NR(3, 19)) : -1;
+}
+#endif
+
+#if 0
+#ifdef CONFIG_USB_EHCI_MX6
+#ifndef CONFIG_DM_USB
+iomux_v3_cfg_t const usb_otg_pads[] = {
+	MX6_PAD_ENET_RX_ER__USB_OTG_ID | MUX_PAD_CTRL(OTG_ID_PAD_CTRL),
+};
+
+static void setup_usb(void)
+{
+	imx_iomux_v3_setup_multiple_pads(usb_otg_pads,
+			ARRAY_SIZE(usb_otg_pads));
+
+	/*
+	  * Set daisy chain for otg_pin_id on 6q.
+	 *  For 6dl, this bit is reserved.
+	 */
+	imx_iomux_set_gpr_register(1, 13, 1, 0);
+}
+
+int board_ehci_power(int port, int on)
+{
+#ifdef CONFIG_PCA953X
+
+#define USB_HOST1_PWR     PORTEXP_IO_NR(0x32, 7)
+#define USB_OTG_PWR       PORTEXP_IO_NR(0x34, 1)
+
+	switch (port) {
+	case 0:
+		if (on)
+			port_exp_direction_output(USB_OTG_PWR, 1);
+		else
+			port_exp_direction_output(USB_OTG_PWR, 0);
+		break;
+	case 1:
+		if (on)
+			port_exp_direction_output(USB_HOST1_PWR, 1);
+		else
+			port_exp_direction_output(USB_HOST1_PWR, 0);
+		break;
+	default:
+		printf("MXC USB port %d not yet supported\n", port);
+		return -EINVAL;
+	}
+#elif defined(CONFIG_DM_PCA953X)
+	struct gpio_desc desc;
+	int ret;
+
+	switch (port) {
+	case 0:		
+		ret = dm_gpio_lookup_name("gpio@34_1", &desc);
+		if (ret)
+			return ret;
+
+		dm_gpio_request(&desc, "usb_otg_pwr");
+		dm_gpio_set_dir_flags(&desc, GPIOD_IS_OUT);
+		
+		if (on)
+			dm_gpio_set_value(&desc, 1);
+		else
+			dm_gpio_set_value(&desc, 0);
+		break;
+	case 1:
+		ret = dm_gpio_lookup_name("gpio@32_7", &desc);
+		if (ret)
+			return ret;
+
+		dm_gpio_request(&desc, "usb_host1_pwr");
+		dm_gpio_set_dir_flags(&desc, GPIOD_IS_OUT);
+		
+		if (on)
+			dm_gpio_set_value(&desc, 1);
+		else
+			dm_gpio_set_value(&desc, 0);
+		break;
+	default:
+		printf("MXC USB port %d not yet supported\n", port);
+		return -EINVAL;
+	}	
+#endif
+	return 0;
+}
+#endif
+#endif
+#endif
+
+int board_early_init_f(void)
+{
+	setup_iomux_uart();
+
+#ifdef CONFIG_MTD_NOR_FLASH
+	eim_clk_setup();
+#endif
+
+	return 0;
+}
+
+static unsigned char usb_init_blob[] = {
+	0x11,	//data size
+	0x24,	//VID LSB
+	0x04,	//VID_MSB
+	0x12,	//PID LSB
+	0x25, //PID MSB
+	0xa0, //DID LSB
+	0x0a, //DID MSB
+	0x8D, //CFG1
+	0x10,	//CFG2
+	0x00,	//CFG3
+	0x00,	//NRD
+	0x08,	//PDS
+	0x08,	//PDB
+	0x01,	//MAXPS
+	0x32,	//MAXPB
+	0x01,	//HCMS
+	0x32,	//HCMB
+	0x32	//PWRT
+};
+static unsigned char usb_init_blob2[] = {
+	0x01,
+	0x01
+};
+
+static unsigned char CPLD_init_blob[] = {
+	0x00,
+	0xff
+};
+
+int board_init(void)
+{
+	struct pmic *p;
+	u32 reg;
+
+	setup_iomux_gpio();
+
+	/* address of boot parameters */
+	gd->bd->bi_boot_params = PHYS_SDRAM + 0x100;
+
+	/* I2C 1 setup */
+    setup_i2c(0, CONFIG_SYS_I2C_SPEED, 0x7f, &i2c_pad_info1);
+    /* I2C 2 setup */
+    setup_i2c(1, CONFIG_SYS_I2C_SPEED, 0x7f, &i2c_pad_info2);
+    /* I2C 3 setup */
+    setup_i2c(2, CONFIG_SYS_I2C_SPEED, 0x7f, &i2c_pad_info3);
+    /* USB HUB reset */
+	gpio_request(IMX_GPIO_NR(7, 8), "hub_reset");
+    gpio_direction_output(IMX_GPIO_NR(7,8),0);
+    udelay(1);
+    gpio_direction_output(IMX_GPIO_NR(7,8),1);
+    udelay(600);
+    /* USB HUB initialization */
+    I2C_SET_BUS(2);
+    i2c_write(0x2c,0,1,usb_init_blob, sizeof(usb_init_blob));
+    i2c_write(0x2c,0xff,1,usb_init_blob2, sizeof(usb_init_blob2));
+    /* Remove Carrier from Reset*/
+    i2c_write(0x04,0,1,CPLD_init_blob, sizeof(CPLD_init_blob));
+    /* Turn on LCD panel*/
+	gpio_request(IMX_GPIO_NR(1, 0), "lcd_vdd_en");
+    gpio_direction_output(IMX_GPIO_NR(1, 0), 1);
+	gpio_request(IMX_GPIO_NR(1, 2), "lcd_bklt_en");
+    gpio_direction_output(IMX_GPIO_NR(1, 2), 1);
+
+#if 1
+	power_ltc3676_init(2);
+	p = pmic_get("LTC3676_PMIC");
+	if (p && !pmic_probe(p)) {
+		puts("PMIC:  LTC3676\n");
+		/* set board-specific scalar to 1225mV for IMX6Q at 1GHz */
+		if (is_cpu_type(MXC_CPU_MX6Q)) {
+			/* mask PGOOD during SW1 transition */
+			reg = 0x13 | LTC3676_PGOOD_MASK;
+			pmic_reg_write(p, LTC3676_DVB1B, reg);
+			/* set SW1 (VDD_SOC) to 1275mV */
+			reg = 0x16;
+			pmic_reg_write(p, LTC3676_DVB1A, reg);
+
+			/* mask PGOOD during SW3 transition */
+			reg = 0x13 | LTC3676_PGOOD_MASK;
+			pmic_reg_write(p, LTC3676_DVB3B, reg);
+			/*set SW3 (VDD_ARM) to 1275mV */
+			reg = 0x16;
+			pmic_reg_write(p, LTC3676_DVB3A, reg);
+		}
+		else
+		{
+			/* mask PGOOD during SW1 transition */
+			reg = 0x13 | LTC3676_PGOOD_MASK;
+			pmic_reg_write(p, LTC3676_DVB1B, reg);
+			/* set SW1 (VDD_SOC) to 1330mV */
+			reg = 0x17;
+			pmic_reg_write(p, LTC3676_DVB1A, reg);
+
+			/* mask PGOOD during SW3 transition */
+			reg = 0x13 | LTC3676_PGOOD_MASK;
+			pmic_reg_write(p, LTC3676_DVB3B, reg);
+			/*set SW3 (VDD_ARM) to 1330mV */
+			reg = 0x17;
+			pmic_reg_write(p, LTC3676_DVB3A, reg);
+		}
+		reg = 0x20;
+		pmic_reg_write(p, LTC3676_BUCK1, reg);
+		reg = 0x20;
+		pmic_reg_write(p, LTC3676_BUCK2, reg);
+		reg = 0x20;
+		pmic_reg_write(p, LTC3676_BUCK3, reg);
+		reg = 0x20;
+		pmic_reg_write(p, LTC3676_BUCK4, reg);		
+	}
+#endif
+
+#ifdef CONFIG_VIDEO_IPUV3
+		setup_display();
+#endif
+
+#ifdef CONFIG_MXC_SPI
+	setup_spinor();
+#endif
+
+#ifdef CONFIG_NAND_MXS
+	setup_gpmi_nand();
+#endif
+
+#ifdef CONFIG_CMD_SATA
+	setup_sata();
+#endif
+
+#ifdef CONFIG_MTD_NOR_FLASH
+	setup_iomux_eimnor();
+#endif
+
+#if 0
+#ifdef CONFIG_FEC_MXC
+	setup_fec();
+#endif
+#endif
+
+#ifdef CONFIG_USB_EHCI_MX6
+#ifndef CONFIG_DM_USB
+	setup_usb();
+#if 0
+else
+	/*
+	  * Set daisy chain for otg_pin_id on 6q.
+	 *  For 6dl, this bit is reserved.
+	 */
+	imx_iomux_set_gpr_register(1, 13, 1, 0);
+#endif
+#endif
+#endif
+
+	return 0;
+}
+
+#if 0
+#ifdef CONFIG_POWER
+int power_init_board(void)
+{
+	struct pmic *pfuze;
+	unsigned int value;
+	int ret;
+
+	pfuze = pfuze_common_init(I2C_PMIC);
+	if (!pfuze)
+		return -ENODEV;
+
+	if (is_mx6dqp())
+		ret = pfuze_mode_init(pfuze, APS_APS);
+	else
+		ret = pfuze_mode_init(pfuze, APS_PFM);
+
+	if (ret < 0)
+		return ret;
+
+	if (is_mx6dqp()) {
+		/* set SW1C staby volatage 1.075V*/
+		pmic_reg_read(pfuze, PFUZE100_SW1CSTBY, &value);
+		value &= ~0x3f;
+		value |= 0x1f;
+		pmic_reg_write(pfuze, PFUZE100_SW1CSTBY, value);
+
+		/* set SW1C/VDDSOC step ramp up time to from 16us to 4us/25mV */
+		pmic_reg_read(pfuze, PFUZE100_SW1CCONF, &value);
+		value &= ~0xc0;
+		value |= 0x40;
+		pmic_reg_write(pfuze, PFUZE100_SW1CCONF, value);
+
+		/* set SW2 staby volatage 0.975V*/
+		pmic_reg_read(pfuze, PFUZE100_SW2STBY, &value);
+		value &= ~0x3f;
+		value |= 0x17;
+		pmic_reg_write(pfuze, PFUZE100_SW2STBY, value);
+
+		/* set SW2/VDDARM step ramp up time to from 16us to 4us/25mV */
+		pmic_reg_read(pfuze, PFUZE100_SW2CONF, &value);
+		value &= ~0xc0;
+		value |= 0x40;
+		pmic_reg_write(pfuze, PFUZE100_SW2CONF, value);
+	} else {
+		/* set SW1AB staby volatage 0.975V*/
+		pmic_reg_read(pfuze, PFUZE100_SW1ABSTBY, &value);
+		value &= ~0x3f;
+		value |= 0x1b;
+		pmic_reg_write(pfuze, PFUZE100_SW1ABSTBY, value);
+
+		/* set SW1AB/VDDARM step ramp up time from 16us to 4us/25mV */
+		pmic_reg_read(pfuze, PFUZE100_SW1ABCONF, &value);
+		value &= ~0xc0;
+		value |= 0x40;
+		pmic_reg_write(pfuze, PFUZE100_SW1ABCONF, value);
+
+		/* set SW1C staby volatage 0.975V*/
+		pmic_reg_read(pfuze, PFUZE100_SW1CSTBY, &value);
+		value &= ~0x3f;
+		value |= 0x1b;
+		pmic_reg_write(pfuze, PFUZE100_SW1CSTBY, value);
+
+		/* set SW1C/VDDSOC step ramp up time to from 16us to 4us/25mV */
+		pmic_reg_read(pfuze, PFUZE100_SW1CCONF, &value);
+		value &= ~0xc0;
+		value |= 0x40;
+		pmic_reg_write(pfuze, PFUZE100_SW1CCONF, value);
+	}
+
+	return 0;
+}
+#elif defined(CONFIG_DM_PMIC_PFUZE100)
+int power_init_board(void)
+{
+	struct udevice *dev;
+	unsigned int reg;
+	int ret;
+
+	dev = pfuze_common_init();
+	if (!dev)
+		return -ENODEV;
+
+	if (is_mx6dqp())
+		ret = pfuze_mode_init(dev, APS_APS);
+	else
+		ret = pfuze_mode_init(dev, APS_PFM);
+	if (ret < 0)
+		return ret;
+
+	if (is_mx6dqp()) {
+		/* set SW1C staby volatage 1.075V*/
+		reg = pmic_reg_read(dev, PFUZE100_SW1CSTBY);
+		reg &= ~0x3f;
+		reg |= 0x1f;
+		pmic_reg_write(dev, PFUZE100_SW1CSTBY, reg);
+
+		/* set SW1C/VDDSOC step ramp up time to from 16us to 4us/25mV */
+		reg = pmic_reg_read(dev, PFUZE100_SW1CCONF);
+		reg &= ~0xc0;
+		reg |= 0x40;
+		pmic_reg_write(dev, PFUZE100_SW1CCONF, reg);
+
+		/* set SW2/VDDARM staby volatage 0.975V*/
+		reg = pmic_reg_read(dev, PFUZE100_SW2STBY);
+		reg &= ~0x3f;
+		reg |= 0x17;
+		pmic_reg_write(dev, PFUZE100_SW2STBY, reg);
+
+		/* set SW2/VDDARM step ramp up time to from 16us to 4us/25mV */
+		reg = pmic_reg_read(dev, PFUZE100_SW2CONF);
+		reg &= ~0xc0;
+		reg |= 0x40;
+		pmic_reg_write(dev, PFUZE100_SW2CONF, reg);
+	} else {
+		/* set SW1AB staby volatage 0.975V*/
+		reg = pmic_reg_read(dev, PFUZE100_SW1ABSTBY);
+		reg &= ~0x3f;
+		reg |= 0x1b;
+		pmic_reg_write(dev, PFUZE100_SW1ABSTBY, reg);
+
+		/* set SW1AB/VDDARM step ramp up time from 16us to 4us/25mV */
+		reg = pmic_reg_read(dev, PFUZE100_SW1ABCONF);
+		reg &= ~0xc0;
+		reg |= 0x40;
+		pmic_reg_write(dev, PFUZE100_SW1ABCONF, reg);
+
+		/* set SW1C staby volatage 0.975V*/
+		reg = pmic_reg_read(dev, PFUZE100_SW1CSTBY);
+		reg &= ~0x3f;
+		reg |= 0x1b;
+		pmic_reg_write(dev, PFUZE100_SW1CSTBY, reg);
+
+		/* set SW1C/VDDSOC step ramp up time to from 16us to 4us/25mV */
+		reg = pmic_reg_read(dev, PFUZE100_SW1CCONF);
+		reg &= ~0xc0;
+		reg |= 0x40;
+		pmic_reg_write(dev, PFUZE100_SW1CCONF, reg);
+	}
+
+	return 0;
+}
+#endif
+#endif
+
+
+#ifdef CONFIG_LDO_BYPASS_CHECK
+#ifdef CONFIG_POWER
+void ldo_mode_set(int ldo_bypass)
+{
+	unsigned int value;
+	struct pmic *p = pmic_get("LTC3676_PMIC");
+
+	if (!p) {
+		printf("No PMIC found!\n");
+		return;
+	}
+
+	/* increase VDDARM/VDDSOC to support 1.2G chip */
+	if (check_1_2G()) {
+		ldo_bypass = 0;	/* ldo_enable on 1.2G chip */
+		printf("1.2G chip, increase VDDARM_IN/VDDSOC_IN\n");
+
+		if (is_mx6dqp()) {
+			/* increase VDDARM to 1.425V */
+			pmic_reg_read(p, PFUZE100_SW2VOL, &value);
+			value &= ~0x3f;
+			value |= 0x29;
+			pmic_reg_write(p, PFUZE100_SW2VOL, value);
+		} else {
+			/* increase VDDARM to 1.425V */
+			pmic_reg_read(p, PFUZE100_SW1ABVOL, &value);
+			value &= ~0x3f;
+			value |= 0x2d;
+			pmic_reg_write(p, PFUZE100_SW1ABVOL, value);
+		}
+		/* increase VDDSOC to 1.425V */
+		pmic_reg_read(p, PFUZE100_SW1CVOL, &value);
+		value &= ~0x3f;
+		value |= 0x2d;
+		pmic_reg_write(p, PFUZE100_SW1CVOL, value);
+	}
+}
+#elif defined(CONFIG_DM_PMIC_PFUZE100)
+void ldo_mode_set(int ldo_bypass)
+{
+	struct udevice *dev;
+	int ret;
+
+	ret = pmic_get("pfuze100", &dev);
+	if (ret == -ENODEV) {
+		printf("No PMIC found!\n");
+		return;
+	}
+
+	/* increase VDDARM/VDDSOC to support 1.2G chip */
+	if (check_1_2G()) {
+		ldo_bypass = 0; /* ldo_enable on 1.2G chip */
+		printf("1.2G chip, increase VDDARM_IN/VDDSOC_IN\n");
+		
+		if (is_mx6dqp()) {
+			/* increase VDDARM to 1.425V */
+			pmic_clrsetbits(dev, PFUZE100_SW2VOL, 0x3f, 0x29);
+		} else {
+			/* increase VDDARM to 1.425V */
+			pmic_clrsetbits(dev, PFUZE100_SW1ABVOL, 0x3f, 0x2d);
+		}
+		/* increase VDDSOC to 1.425V */
+		pmic_clrsetbits(dev, PFUZE100_SW1CVOL, 0x3f, 0x2d);
+	}
+}
+#endif
+#endif
+
+#ifdef CONFIG_CMD_BMODE
+static const struct boot_mode board_boot_modes[] = {
+	/* 4 bit bus width */
+	{"sd1",	 MAKE_CFGVAL(0x40, 0x28, 0x00, 0x00)},
+	/* 8 bit bus width */
+	{"emmc", MAKE_CFGVAL(0x40, 0x38, 0x00, 0x00)},
+	{"exmmc", MAKE_CFGVAL(0x40, 0x38, 0x00, 0x00)},
+	{NULL,   0},
+};
+#endif
+
+int board_late_init(void)
+{
+#ifdef CONFIG_CMD_BMODE
+	add_board_boot_modes(board_boot_modes);
+#endif
+
+#ifdef CONFIG_ENV_VARS_UBOOT_RUNTIME_CONFIG
+	setenv("board_name", "EZ-ROJ-1");
+
+	if (is_mx6dqp())
+		setenv("board_rev", "MX6QP");
+	else if (is_mx6dq())
+		setenv("board_rev", "MX6Q");
+	else if (is_mx6sdl())
+		setenv("board_rev", "MX6DL");
+#endif
+
+#ifdef CONFIG_ENV_IS_IN_MMC
+	board_late_mmc_env_init();
+	u32 dev_no = mmc_get_env_dev();
+	setenv_ulong("mmcdevk", mmc_map_to_kernel_blk(dev_no));
+#endif
+
+	return 0;
+}
+
+int checkboard(void)
+{
+	int rev = mx6smarc_rev();
+	char *revname;
+
+	switch (rev) {
+	case BOARD_REV_B:
+		revname = "B";
+		break;
+	case BOARD_REV_A:
+	default:
+		revname = "A";
+		break;
+	}
+
+	printf("Board: MX6Q-Smarc rev%s\n", revname);
+
+	return 0;
+}
+
+#ifdef CONFIG_FSL_FASTBOOT
+#ifdef CONFIG_ANDROID_RECOVERY
+
+#define GPIO_VOL_DN_KEY IMX_GPIO_NR(5, 14)
+iomux_v3_cfg_t const recovery_key_pads[] = {
+	(MX6_PAD_DISP0_DAT20__GPIO5_IO14 | MUX_PAD_CTRL(NO_PAD_CTRL)),
+};
+
+int is_recovery_key_pressing(void)
+{
+	int button_pressed = 0;
+
+	/* Check Recovery Combo Button press or not. */
+	imx_iomux_v3_setup_multiple_pads(recovery_key_pads,
+		ARRAY_SIZE(recovery_key_pads));
+
+	gpio_request(GPIO_VOL_DN_KEY, "volume_dn_key");
+	gpio_direction_input(GPIO_VOL_DN_KEY);
+
+	if (gpio_get_value(GPIO_VOL_DN_KEY) == 0) { /* VOL_DN key is low assert */
+		button_pressed = 1;
+		printf("Recovery key pressed\n");
+	}
+
+	return  button_pressed;
+}
+
+#endif /*CONFIG_ANDROID_RECOVERY*/
+
+#endif /*CONFIG_FSL_FASTBOOT*/
diff --git a/include/configs/mx6qsmarc.h b/include/configs/mx6qsmarc.h
new file mode 100644
index 0000000..4261eee
--- /dev/null
+++ b/include/configs/mx6qsmarc.h
@@ -0,0 +1,64 @@
+/*
+ * Copyright (C) 2012-2016 Freescale Semiconductor, Inc.
+ *
+ * Configuration settings for the ROJ SMARC SOM.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef __MX6QSMARC_CONFIG_H
+#define __MX6QSMARC_CONFIG_H
+
+#define CONFIG_MACH_TYPE	3529
+#define CONFIG_MXC_UART_BASE	UART2_BASE
+#define CONSOLE_DEV		"ttymxc1"
+#define CONFIG_MMCROOT		"/dev/mmcblk0p2"
+
+#if defined CONFIG_MX6Q
+	#define PHYS_SDRAM_SIZE		(1u * 1024 * 1024 * 1024)
+#elif defined CONFIG_MX6DL
+	#define PHYS_SDRAM_SIZE		(1u * 512 * 1024 * 1024)
+#endif
+
+#ifdef CONFIG_MX6S
+#undef PHYS_SDRAM_SIZE
+#define PHYS_SDRAM_SIZE		(1u * 1024 * 1024 * 1024)
+#endif
+
+#include "mx6smarc_common.h"
+
+#undef MFG_NAND_PARTITION
+#ifdef CONFIG_NAND_BOOT
+#define MFG_NAND_PARTITION "mtdparts=8000000.nor:1m(boot),-(rootfs)\\\\;gpmi-nand:64m(boot),16m(kernel),16m(dtb),1m(misc),-(rootfs) "
+#else
+#define MFG_NAND_PARTITION ""
+#endif
+
+#define CONFIG_SYS_FSL_USDHC_NUM	3
+#define CONFIG_SYS_MMC_ENV_DEV		1
+#define CONFIG_SYS_MMC_ENV_PART                0       /* user partition */
+
+#ifdef CONFIG_CMD_SF
+#define CONFIG_SF_DEFAULT_CS   1
+#endif
+
+/*Since the pin conflicts on EIM D18, disable the USB host if the NOR flash is enabled */
+#ifdef CONFIG_USB
+/* USB Configs */
+#define CONFIG_USB_EHCI
+#define CONFIG_USB_EHCI_MX6
+#define CONFIG_USB_HOST_ETHER
+#define CONFIG_USB_ETHER_ASIX
+#define CONFIG_USB_MAX_CONTROLLER_COUNT 2
+#define CONFIG_EHCI_HCD_INIT_AFTER_RESET	/* For OTG port */
+#define CONFIG_MXC_USB_PORTSC	(PORT_PTS_UTMI | PORT_PTS_PTW)
+#define CONFIG_MXC_USB_FLAGS	0
+
+#if !defined(CONFIG_DM_PCA953X) && defined(CONFIG_SYS_I2C)
+#define CONFIG_PCA953X
+#define CONFIG_SYS_I2C_PCA953X_WIDTH	{ {0x30, 8}, {0x32, 8}, {0x34, 8} }
+#endif
+
+#endif
+
+#endif                         /* __MX6QSMARC_CONFIG_H */
diff --git a/include/configs/mx6smarc_common.h b/include/configs/mx6smarc_common.h
new file mode 100644
index 0000000..0729194
--- /dev/null
+++ b/include/configs/mx6smarc_common.h
@@ -0,0 +1,400 @@
+/*
+ * Copyright (C) 2012 Freescale Semiconductor, Inc.
+ *
+ * Configuration settings for the ROJ SMARC SOM.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef __MX6QSMARC_COMMON_CONFIG_H
+#define __MX6QSMARC_COMMON_CONFIG_H
+
+#include "mx6_common.h"
+
+#define CONFIG_IMX_THERMAL
+
+/* Size of malloc() pool */
+#define CONFIG_SYS_MALLOC_LEN		(16 * SZ_1M)
+
+#define CONFIG_MXC_UART
+
+/* MMC Configs */
+#define CONFIG_SYS_FSL_ESDHC_ADDR      0
+
+#define CONFIG_FEC_MXC
+#define CONFIG_MII
+#define IMX_FEC_BASE			ENET_BASE_ADDR
+#define CONFIG_FEC_XCV_TYPE		RGMII
+#ifdef CONFIG_DM_ETH
+#define CONFIG_ETHPRIME			"eth0"
+#else
+#define CONFIG_ETHPRIME			"FEC"
+#endif
+#define CONFIG_FEC_MXC_PHYADDR		4
+
+#define CONFIG_PHYLIB
+#define CONFIG_PHY_MICREL
+
+#ifdef CONFIG_MX6S
+#define SYS_NOSMP "nosmp"
+#else
+#define SYS_NOSMP
+#endif
+
+/* Command definition */
+#define CONFIG_CMD_BMODE
+
+#ifdef CONFIG_NAND_BOOT
+#define MFG_NAND_PARTITION "mtdparts=gpmi-nand:64m(boot),16m(kernel),16m(dtb),1m(misc),-(rootfs) "
+#else
+#define MFG_NAND_PARTITION ""
+#endif
+
+#define CONFIG_MFG_ENV_SETTINGS \
+	"mfgtool_args=setenv bootargs console=" CONSOLE_DEV ",115200 " \
+		"rdinit=/linuxrc " \
+		"g_mass_storage.stall=0 g_mass_storage.removable=1 " \
+		"g_mass_storage.file=/fat g_mass_storage.ro=1 " \
+		"g_mass_storage.idVendor=0x066F g_mass_storage.idProduct=0x37FF "\
+		"g_mass_storage.iSerialNumber=\"\" "\
+		"enable_wait_mode=off "\
+		MFG_NAND_PARTITION \
+		"\0" \
+		"initrd_addr=0x12C00000\0" \
+		"initrd_high=0xffffffff\0" \
+		"bootcmd_mfg=run mfgtool_args;bootz ${loadaddr} ${initrd_addr} ${fdt_addr};\0" \
+
+
+#ifdef CONFIG_SUPPORT_EMMC_BOOT
+#define EMMC_ENV \
+	"emmcdev=1\0" \
+	"update_emmc_firmware=" \
+		"if test ${ip_dyn} = yes; then " \
+			"setenv get_cmd dhcp; " \
+		"else " \
+			"setenv get_cmd tftp; " \
+		"fi; " \
+		"if ${get_cmd} ${update_sd_firmware_filename}; then " \
+			"if mmc dev ${emmcdev} 1; then "	\
+				"setexpr fw_sz ${filesize} / 0x200; " \
+				"setexpr fw_sz ${fw_sz} + 1; "	\
+				"mmc write ${loadaddr} 0x2 ${fw_sz}; " \
+			"fi; "	\
+		"fi\0"
+#else
+#define EMMC_ENV ""
+#endif
+
+#define CONFIG_ENV_VARS_UBOOT_RUNTIME_CONFIG
+
+#if defined(CONFIG_NAND_BOOT)
+	/*
+	 * The dts also enables the WEIN NOR which is mtd0.
+	 * So the partions' layout for NAND is:
+	 *     mtd1: 16M      (uboot)
+	 *     mtd2: 16M      (kernel)
+	 *     mtd3: 16M      (dtb)
+	 *     mtd4: left     (rootfs)
+	 */
+#define CONFIG_EXTRA_ENV_SETTINGS \
+	CONFIG_MFG_ENV_SETTINGS \
+	"fdt_addr=0x18000000\0" \
+	"fdt_high=0xffffffff\0"	  \
+	"bootargs=console=" CONSOLE_DEV ",115200 ubi.mtd=5 "  \
+		"root=ubi0:rootfs rootfstype=ubifs "		     \
+		"mtdparts=gpmi-nand:64m(boot),16m(kernel),16m(dtb),1m(misc),-(rootfs)\0"\
+	"bootcmd=nand read ${loadaddr} 0x4000000 0x800000;"\
+		"nand read ${fdt_addr} 0x5000000 0x100000;"\
+		"bootz ${loadaddr} - ${fdt_addr}\0"
+
+#elif defined(CONFIG_SATA_BOOT)
+
+#define CONFIG_EXTRA_ENV_SETTINGS \
+		CONFIG_MFG_ENV_SETTINGS \
+		"fdt_addr=0x18000000\0" \
+		"fdt_high=0xffffffff\0"   \
+		"bootargs=console=" CONSOLE_DEV ",115200 \0"\
+		"bootargs_sata=setenv bootargs ${bootargs} " \
+			"root=/dev/sda1 rootwait rw \0" \
+		"bootcmd_sata=run bootargs_sata; sata init; " \
+			"sata read ${loadaddr} 0x800  0x4000; " \
+			"sata read ${fdt_addr} 0x8000 0x800; " \
+			"bootz ${loadaddr} - ${fdt_addr} \0" \
+		"bootcmd=run bootcmd_sata \0"
+
+#else
+
+#define CONFIG_EXTRA_ENV_SETTINGS \
+	CONFIG_MFG_ENV_SETTINGS \
+	"epdc_waveform=epdc_splash.bin\0" \
+	"script=boot.scr\0" \
+	"image=zImage\0" \
+	"fdt_file=undefined\0" \
+	"fdt_addr=0x18000000\0" \
+	"boot_fdt=try\0" \
+	"ip_dyn=yes\0" \
+	"console=" CONSOLE_DEV "\0" \
+	"dfuspi=dfu 0 sf 0:0:10000000:0\0" \
+	"dfu_alt_info_spl=spl raw 0x400\0" \
+	"dfu_alt_info_img=u-boot raw 0x10000\0" \
+	"dfu_alt_info=spl raw 0x400\0" \
+	"fdt_high=0xffffffff\0"	  \
+	"initrd_high=0xffffffff\0" \
+	"mmcdev=" __stringify(CONFIG_SYS_MMC_ENV_DEV) "\0" \
+	"mmcdevk=1\0" \
+	"mmcpart=1\0" \
+	"mmcroot=" CONFIG_MMCROOT " rootwait rw\0" \
+	"mmcrootpart=2\0" \
+	"mmcautodetect=yes\0" \
+	"update_sd_firmware=" \
+		"if test ${ip_dyn} = yes; then " \
+			"setenv get_cmd dhcp; " \
+		"else " \
+			"setenv get_cmd tftp; " \
+		"fi; " \
+		"if mmc dev ${mmcdev}; then "	\
+			"if ${get_cmd} ${update_sd_firmware_filename}; then " \
+				"setexpr fw_sz ${filesize} / 0x200; " \
+				"setexpr fw_sz ${fw_sz} + 1; "	\
+				"mmc write ${loadaddr} 0x2 ${fw_sz}; " \
+			"fi; "	\
+		"fi\0" \
+	EMMC_ENV	  \
+	"smp=" SYS_NOSMP "\0"\
+	"mmcsetroot=setenv mmcroot /dev/mmcblk${mmcdevk}p${mmcrootpart} rootwait rw\0" \
+	"mmcargs=run mmcsetroot;setenv bootargs console=${console},${baudrate} ${smp} " \
+		"root=${mmcroot}\0" \
+	"loadbootscript=" \
+		"fatload mmc ${mmcdev}:${mmcpart} ${loadaddr} ${script};\0" \
+	"bootscript=echo Running bootscript from mmc ...; " \
+		"source\0" \
+	"loadimage=fatload mmc ${mmcdev}:${mmcpart} ${loadaddr} ${image}\0" \
+	"loadfdt=fatload mmc ${mmcdev}:${mmcpart} ${fdt_addr} ${fdt_file}\0" \
+	"mmcboot=echo Booting from mmc ...; " \
+		"run mmcargs; " \
+		"if test ${boot_fdt} = yes || test ${boot_fdt} = try; then " \
+			"if run loadfdt; then " \
+				"bootz ${loadaddr} - ${fdt_addr}; " \
+			"else " \
+				"if test ${boot_fdt} = try; then " \
+					"bootz; " \
+				"else " \
+					"echo WARN: Cannot load the DT; " \
+				"fi; " \
+			"fi; " \
+		"else " \
+			"bootz; " \
+		"fi;\0" \
+	"netargs=setenv bootargs console=${console},${baudrate} ${smp} " \
+		"root=/dev/nfs " \
+		"ip=dhcp nfsroot=${serverip}:${nfsroot},v3,tcp\0" \
+	"netboot=echo Booting from net ...; " \
+		"run netargs; " \
+		"if test ${ip_dyn} = yes; then " \
+			"setenv get_cmd dhcp; " \
+		"else " \
+			"setenv get_cmd tftp; " \
+		"fi; " \
+		"${get_cmd} ${image}; " \
+		"if test ${boot_fdt} = yes || test ${boot_fdt} = try; then " \
+			"if ${get_cmd} ${fdt_addr} ${fdt_file}; then " \
+				"bootz ${loadaddr} - ${fdt_addr}; " \
+			"else " \
+				"if test ${boot_fdt} = try; then " \
+					"bootz; " \
+				"else " \
+					"echo WARN: Cannot load the DT; " \
+				"fi; " \
+			"fi; " \
+		"else " \
+			"bootz; " \
+		"fi;\0" \
+		"findfdt="\
+			"if test $fdt_file = undefined; then " \
+				"if test $board_name = EZ-ROJ-1 && test $board_rev = MX6QP; then " \
+					"setenv fdt_file imx6qp-enuc.dtb; fi; " \
+				"if test $board_name = EZ-ROJ-1 && test $board_rev = MX6Q; then " \
+					"setenv fdt_file imx6q-enuc.dtb; fi; " \
+				"if test $board_name = EZ-ROJ-1 && test $board_rev = MX6DL; then " \
+					"setenv fdt_file imx6dl-enuc.dtb; fi; " \
+				"if test $fdt_file = undefined; then " \
+					"echo WARNING: Could not determine dtb to use; fi; " \
+			"fi;\0" \
+
+#define CONFIG_BOOTCOMMAND \
+	"run findfdt;" \
+	"mmc dev ${mmcdev};" \
+	"if mmc rescan; then " \
+		"if run loadbootscript; then " \
+		"run bootscript; " \
+		"else " \
+			"if run loadimage; then " \
+				"run mmcboot; " \
+			"else run netboot; " \
+			"fi; " \
+		"fi; " \
+	"else run netboot; fi"
+#endif
+
+#define CONFIG_ARP_TIMEOUT     200UL
+
+#define CONFIG_SYS_MEMTEST_START       0x10000000
+#define CONFIG_SYS_MEMTEST_END         0x10010000
+#define CONFIG_SYS_MEMTEST_SCRATCH     0x10800000
+
+#define CONFIG_STACKSIZE               (128 * 1024)
+
+/* Physical Memory Map */
+#define CONFIG_NR_DRAM_BANKS           1
+#define PHYS_SDRAM                     MMDC0_ARB_BASE_ADDR
+
+#define CONFIG_SYS_SDRAM_BASE          PHYS_SDRAM
+#define CONFIG_SYS_INIT_RAM_ADDR       IRAM_BASE_ADDR
+#define CONFIG_SYS_INIT_RAM_SIZE       IRAM_SIZE
+
+#define CONFIG_SYS_INIT_SP_OFFSET \
+	(CONFIG_SYS_INIT_RAM_SIZE - GENERATED_GBL_DATA_SIZE)
+#define CONFIG_SYS_INIT_SP_ADDR \
+	(CONFIG_SYS_INIT_RAM_ADDR + CONFIG_SYS_INIT_SP_OFFSET)
+
+/* Environment organization */
+#define CONFIG_ENV_SIZE			(8 * 1024)
+
+#if defined CONFIG_SPI_BOOT
+#define CONFIG_CMD_SF
+#define CONFIG_ENV_IS_IN_SPI_FLASH
+#elif defined CONFIG_NOR_BOOT
+#define CONFIG_MTD_NOR_FLASH
+#define CONFIG_ENV_IS_IN_FLASH
+#elif defined CONFIG_NAND_BOOT
+#define CONFIG_CMD_NAND
+#define CONFIG_ENV_IS_IN_NAND
+#elif defined CONFIG_SATA_BOOT
+#define CONFIG_ENV_IS_IN_SATA
+#define CONFIG_CMD_SATA
+#else
+#define CONFIG_ENV_IS_IN_MMC
+#endif
+
+#ifdef CONFIG_CMD_SATA
+#define CONFIG_DWC_AHSATA
+#define CONFIG_SYS_SATA_MAX_DEVICE	1
+#define CONFIG_DWC_AHSATA_PORT_ID	0
+#define CONFIG_DWC_AHSATA_BASE_ADDR	SATA_ARB_BASE_ADDR
+#define CONFIG_LBA48
+#define CONFIG_LIBATA
+#endif
+
+#ifdef CONFIG_CMD_SF
+#define CONFIG_SPI_FLASH
+#define CONFIG_SPI_FLASH_STMICRO
+#define CONFIG_MXC_SPI
+#define CONFIG_SF_DEFAULT_BUS  0
+#define CONFIG_SF_DEFAULT_SPEED 20000000
+#define CONFIG_SF_DEFAULT_MODE (SPI_MODE_0)
+#endif
+
+#ifdef CONFIG_MTD_NOR_FLASH
+#define CONFIG_SYS_FLASH_BASE           WEIM_ARB_BASE_ADDR
+#define CONFIG_SYS_FLASH_SECT_SIZE      (128 * 1024)
+#define CONFIG_SYS_MAX_FLASH_BANKS 1    /* max number of memory banks */
+#define CONFIG_SYS_MAX_FLASH_SECT 256   /* max number of sectors on one chip */
+#define CONFIG_SYS_FLASH_CFI            /* Flash memory is CFI compliant */
+#define CONFIG_FLASH_CFI_DRIVER         /* Use drivers/cfi_flash.c */
+#define CONFIG_SYS_FLASH_USE_BUFFER_WRITE /* Use buffered writes*/
+#define CONFIG_SYS_FLASH_EMPTY_INFO
+#define CONFIG_SYS_FLASH_CFI_WIDTH	FLASH_CFI_16BIT
+#endif
+
+#ifdef CONFIG_CMD_NAND
+/* NAND flash command */
+#define CONFIG_CMD_NAND_TRIMFFS
+
+/* NAND stuff */
+#define CONFIG_NAND_MXS
+#define CONFIG_SYS_MAX_NAND_DEVICE     1
+#define CONFIG_SYS_NAND_BASE           0x40000000
+#define CONFIG_SYS_NAND_5_ADDR_CYCLE
+#define CONFIG_SYS_NAND_ONFI_DETECTION
+
+/* DMA stuff, needed for GPMI/MXS NAND support */
+#define CONFIG_APBH_DMA
+#define CONFIG_APBH_DMA_BURST
+#define CONFIG_APBH_DMA_BURST8
+#endif
+
+
+#if defined(CONFIG_ENV_IS_IN_MMC)
+#define CONFIG_ENV_OFFSET		(896 * 1024)
+#elif defined(CONFIG_ENV_IS_IN_SPI_FLASH)
+#define CONFIG_ENV_OFFSET              (896 * 1024)
+#define CONFIG_ENV_SECT_SIZE           (64 * 1024)
+#define CONFIG_ENV_SPI_BUS             CONFIG_SF_DEFAULT_BUS
+#define CONFIG_ENV_SPI_CS              CONFIG_SF_DEFAULT_CS
+#define CONFIG_ENV_SPI_MODE            CONFIG_SF_DEFAULT_MODE
+#define CONFIG_ENV_SPI_MAX_HZ          CONFIG_SF_DEFAULT_SPEED
+#elif defined(CONFIG_ENV_IS_IN_FLASH)
+#undef CONFIG_ENV_SIZE
+#define CONFIG_ENV_SIZE                        CONFIG_SYS_FLASH_SECT_SIZE
+#define CONFIG_ENV_SECT_SIZE           CONFIG_SYS_FLASH_SECT_SIZE
+#define CONFIG_ENV_OFFSET              (7 * CONFIG_SYS_FLASH_SECT_SIZE)
+#elif defined(CONFIG_ENV_IS_IN_NAND)
+#undef CONFIG_ENV_SIZE
+#define CONFIG_ENV_OFFSET              (60 << 20)
+#define CONFIG_ENV_SECT_SIZE           (128 << 10)
+#define CONFIG_ENV_SIZE                        CONFIG_ENV_SECT_SIZE
+#elif defined(CONFIG_ENV_IS_IN_SATA)
+#define CONFIG_ENV_OFFSET		(896 * 1024)
+#define CONFIG_SYS_SATA_ENV_DEV		0
+#define CONFIG_SYS_DCACHE_OFF /* remove when sata driver support cache */
+#endif
+
+/* I2C Configs */
+#ifndef CONFIG_DM_I2C
+#define CONFIG_SYS_I2C
+#endif
+#ifdef CONFIG_CMD_I2C
+#define CONFIG_SYS_I2C_MXC
+#define CONFIG_SYS_I2C_MXC_I2C1		/* enable I2C bus 1 */
+#define CONFIG_SYS_I2C_MXC_I2C2		/* enable I2C bus 2 */
+#define CONFIG_SYS_I2C_MXC_I2C3		/* enable I2C bus 3 */
+#define CONFIG_SYS_I2C_SPEED		  100000
+#endif
+
+/* PMIC */
+#ifndef CONFIG_DM_PMIC
+#define CONFIG_POWER
+#define CONFIG_POWER_I2C
+#define CONFIG_POWER_LTC3676
+#define CONFIG_POWER_LTC3676_I2C_ADDR 0x3c
+#endif
+
+/* Framebuffer */
+#define CONFIG_VIDEO_IPUV3
+#define CONFIG_VIDEO_BMP_RLE8
+#define CONFIG_SPLASH_SCREEN
+#define CONFIG_SPLASH_SCREEN_ALIGN
+#define CONFIG_BMP_16BPP
+#define CONFIG_VIDEO_LOGO
+#define CONFIG_VIDEO_BMP_LOGO
+#ifdef CONFIG_MX6DL
+#define CONFIG_IPUV3_CLK 198000000
+#else
+#define CONFIG_IPUV3_CLK 264000000
+#endif
+#define CONFIG_IMX_HDMI
+#define CONFIG_IMX_VIDEO_SKIP
+
+#if defined(CONFIG_ANDROID_SUPPORT)
+#include "mx6sabreandroid_common.h"
+#else
+
+#ifndef CONFIG_SPL
+#define CONFIG_USBD_HS
+
+#define CONFIG_USB_FUNCTION_MASS_STORAGE
+#endif
+
+#endif /* CONFIG_ANDROID_SUPPORT */
+
+#endif                         /* __MX6QSMARC_COMMON_CONFIG_H */
-- 
2.17.1

